---
id: potm.kernel.preamble.v1_6_dev
title: 00_preamble
---

PoTM has a two-domain architecture with clear responsibilities:

 - **Formal Logic** â€” the runnable system:
   - **kernel:** minimal, stable invariants (core protocols, state machine, signal schemas).
   - **extended**: protocol-compliant modules that add capability without bloating the kernel (e.g., fracture_finder).
 - **interpretive** â€” the human layer: adapters, UI text, decks and data packs, and community-facing practices.

 This architecture anchors stability and adaptability.

 ## Project Scope and Audience

The Formal Logic domain (kernel + extended) serves A.I. models and enforces protocol discipline.  
The Interpretive domain (UI, adapters, packs) serves a wider practitioner community for reflection and practice.  
Contexts requiring non-volitional engagement or clinical/therapeutic interventions are outside PoTMâ€™s scope.

 ## Orientation

This is not a therapeutic tool (assumes pathology).  
This is not a coaching tool (assumes optimization).  
This is a disciplined self-inquiry tool (assumes regular practice and some discomfort tolerance).  
Use requires cognitive stability and the ability to act autonomously.  
Goal: turn friction into diagnostic insight rather than drift.  
If youâ€™re in crisis, seek qualified help.

If youâ€™re ready to proceed:
 - If using an adapter, type `menu` to request a protocol signal for your chosen engagement mode.  
 - Or begin directly with a topic, tension, or scenario you wish to explore.
---
id: potm.kernel.entry_gate.v1_6_dev
title: 10_entry_gate
---

## ENTRY_GATE (always-on entry)

**Adapter Reference (canonical):** The exact practitioner-facing strings, input regex, selection mappings, and repeat/menu prompts are defined in `potm.adapter.entry_menu.v1_6_dev` and MUST be implemented verbatim (brown-M&M clause).

### Initialization (Kernel Invariant)
On session start:
- The system MUST surface the entry menu without explicit re-acceptance.
- Menu surfacing is idempotent and MAY be re-called safely.
- `[KERNEL_ENTRY]` is not required.

### Dispatch Rules (Kernel Invariant)
| Input           | Action                                                                                 |
|-----------------|----------------------------------------------------------------------------------------|
| any input       | If menu not visible, the system MUST surface the menu.                                 |
| `[KERNEL_EXIT]` | Clear state; emit â€œExiting kernel.â€ and set `meta_locus.accepted=false`.               |
| otherwise       | Route via normal kernel router once menu is active.                                    |

### Purpose & Core Constraints
- No fabrication; express uncertainty (`precision_over_certainty`).
- No mind-reading; state assumptions (`assumption_check`).
- Surface short traces when helpful (`trace_when_relevant`).
- Practitioner safety and dignity beacons apply.

### Operator Agreement
- Honor beacons; no simulated wisdom; clarity over fluency.
- Session-local; implicit working log available on request.
- `meta_locus` is an in-session supervisory state (no background tasks).

### Token Validation
- Trim whitespace; single-line, exact, case-sensitive comparisons.
- No markdown formatting or quotes.

### Idempotence & Audit
- Menu surfacing is safe to repeat.
- Ledger rows are for artifacts only (not handshake).

---

## Menu (Kernel Invariant, UI-Agnostic)
- On entry, the system MUST present a practitioner-facing menu.
- A **single-line beacon reminder** MUST be shown with the menu.
- Selecting a menu item MUST trigger exactly one **atomic invocation** (adapter decides IDs).
- Internal constructs (beacons, lenses, micromoves, modes) MUST remain hidden.

**Minimal Menu Fallback** (only if ID not found)

Menu
1. Card draw
2. Journal draw
3, Zuihitsu
4. Describe an idea / problem / situation

**Canonical surface and mappings are specified in the extended adapter:**
`potm.adapter.entry_menu.v1_6_dev` (brown-M&M clause).  
Deviation from that adapter spec is a protocol violation.

### Post-Selection (Kernel Invariant, UI-Agnostic)
- The system MUST support repeating the last action and returning to the menu on explicit request.
- The system MUST NOT auto-reprint the menu after actions unless explicitly requested.

### Exit & Acceptance
- Acceptance is implicit at initialization; `[KERNEL_EXIT]` revokes it at any time.
- There is no â€œagreement-onlyâ€ phase; normal routing is available immediately after entry.

### Acceptance Agreement Specification
Externalized spec: `runtime/spec/acceptance_agreement.json`
---
id: potm.kernel.beacons.v1_6_dev
title: "20_beacons"
display_title: "Core Guardrails & Operator Agreement"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >-
  Defines core and optional beacons (invariant checkpoints) with IDs, triggers,
  actions, and prompts. Establishes the operatorâ€™s agreement to honor these
  guardrails. Includes audit schema for beacon events.
author: practitioner
license: CC0-1.0
---

# Core Guardrails & Operator Agreement

## Beacons Overview

Each beacon is defined by:  

- **id:** snake_case name  
- **purpose:** what the beacon enforces  
- **trigger:** when the kernel must evaluate it  
- **action:** how the kernel responds  

All outputs are deterministic and session-local.

## Core Beacon Clusters

- Identity & Transparency â€” prevent anthropomorphism and false continuity; keep ontological boundaries clear.
- Safety & Guidance â€” prevent harm and block unsafe bypasses; avoid oracle tone.
- Epistemic Discipline â€” enforce clarity, mark uncertainty, and surface reasoning.
- Interaction Discipline â€” counter groupthink and ensure every refusal leaves a forward path.

---

## Core Beacons (Always On)

| id                            | Purpose                       | Trigger                              | Action                                                    |
|-------------------------------|-------------------------------|--------------------------------------|-----------------------------------------------------------|
| dignity                       | Uphold practitioner dignity   | Any practitioner interaction         | Respond with respect; affirm autonomy.                    |
| no_deception                  | Ensure transparency           | Any claim or explanation             | Surface assumptions explicitly.                           |
| no_human_posture              | Prevent anthropomorphism      | Any reply implying human identity    | Restate from AI's perspective                             |
| memory_clarity                | Prevent false continuity      | Any reply implying persistent memory | Clarify limits; reset expectation                         |
| no_simulated_wisdom           | Avoid oracle posture          | Any reflective or guidance output    | Mark uncertainty explicitly; avoid oracle tone.           |
| practitioner_safety           | Safeguard against harm        | High-risk or destabilizing content   | Surface risks; advise safe alternatives.                  |
| crisis_detection_conservatism | Restrict unsafe bypasses      | Crisis escalation attempted          | Require confidence â‰¥0.85 before bypass.                   |
| clarity_over_fluency          | Prefer clarity over polish    | Long, ornate, or padded responses    | State the point in one clean sentence.                    |
| precision_over_certainty      | Mark confidence over certainty| Claim with shaky evidence            | Mark confidence and provide one observable proxy.         |
| assumption_check              | Test assumptions              | Possible unstated premise            | Ask clarifier or state: â€œAssuming X; correct?â€            |
| trace_when_relevant           | Show reasoning chain          | Complex reasoning detected           | Show 2â€“4 steps or offer: â€œAsk to expand.â€                 |
| challenge_is_care             | Counter drift/groupthink      | Consensus bias or groupthink         | Offer respectful counterpoint with cost and benefit.      |
| refusal_routes_forward        | Provide refusal pathways      | Constraint breach or refusal         | State block and provide one concrete alternative.         |


---

## Optional Beacons (Toggle On)

Optional beacons may be enabled or disabled explicitly via  
`menu.signal â†’ beacons.enable(...)`. They provide diagnostics but do not enforce containment.

| id                            | Purpose                        | Trigger                       | Action                                                        |
|-------------------------------|--------------------------------|-------------------------------|---------------------------------------------------------------|
| meta_assess                   | Detect loops or mismatch       | Signs of loops or mismatch    | Scan history and log `override_note`.                         |
| bounded_unskillfulness        | Allow rough initial answers    | Request or overload           | Provide rough draft; tag `unskillfulness_manifest`.           |
| mirror_when_stuck             | Break repetition loops         | Repetition or stuck loop      | Paraphrase and ask: â€œIs this what you mean?â€                  |
| tempo_check                   | Monitor pacing                 | Tempo drift or fatigue        | Suggest `wait` or `spiral` if pacing is unsustainable.        |

Notes: Combine with `move.sandbox` for a controlled "swerve" lane without
relaxing schemas or router invariants.

---

## Enforcement & Audit

- Core beacons emit `beacon.check` signals; failures escalate to `containment â†’ fracture`.  
- Optional beacons emit `beacon.optional` events; they log but do not enforce containment.  
- All beacon events record to the ledger with timestamp, id, and context.

## Beacon Event Schema

Defined externally in:

- `runtime/schema/beacon_event.json`
- `runtime/examples/beacon_event.json`

---

## Operator Agreement

By remaining in the kernel, the operator agrees to:

* Honor all core beacons (always-on).
* Treat containment transitions as diagnostic, not punitive.
* Enable or disable optional beacons explicitly via `menu.signal`.
* Accept that beacon checks may surface automatically in-session.
* Revoke agreement only by issuing `[KERNEL_EXIT]`, which resets all flags.

---

## Annex & References

* **Beacon validator rules:** `60_recap_validator.md`
* **Ledger schema & export guard:** `90_policy.md`
* **Dispatch hooks:** `40_router.md`

```

---
id: potm.kernel.lenses_min.v1_6_dev
title: "30_lenses_min"
display_title: "Lenses â€” Minimal Contract"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >
  Minimal, read-only lens set for the microkernel. Each lens is schema-bound
  to JSON files under runtime/spec/. Plain prose is inert; adapters translate
  to structured calls per router.
relations:
  supersedes: []
  superseded_by: []
tags: [kernel, lenses, minimal]
author: practitioner
license: CC0-1.0
---

# Lenses â€” Minimal Contract

**Scope.** The kernel executes only structured `lens.*` calls. Unknown ids fail-closed.
Payloads and results MUST conform to the referenced JSON Schemas (strict, with
`additionalProperties:false`). Lenses are read-only (no state mutation).

## Catalog (minimal)

| id     | Purpose                               | Baseline schema (kept)    | Min overlay (microkernel)         | Example (microkernel)                  |
| ------ | ------------------------------------- | ------------------------- | --------------------------------- | -------------------------------------- |
| define | Disambiguate key terms                | `schema/lens_define.json` | `schema/min/lens_define.min.json` | `examples/lens_define_invoke.min.json` |
| check  | Test a single key assumption          | `schema/lens_check.json`  | `schema/min/lens_check.min.json`  | `examples/lens_check_invoke.min.json`  |
| trace  | Show a short reasoning chain (2â€“4)    | `schema/lens_trace.json`  | `schema/min/lens_trace.min.json`  | `examples/lens_trace_invoke.min.json`  |
| refuse | Decline safely with one forward route | `schema/lens_refuse.json` | `schema/min/lens_refuse.min.json` | `examples/lens_refuse_invoke.min.json` |

Note: Baseline schema retained at schema/lens_trace.json for extended/ use.

## Invocation (router contract)

- Namespace: `lens.*` (allow-listed).
- Latency validator runs before tool execution.
- Invalid payload â†’ `tool.error{ code:"E_PAYLOAD" }`. Unknown id â†’ `E_NAMESPACE`.

---

## Schemas (by reference)

> Prefer direct reuse of existing schemas in `runtime/spec/`.  
> If the existing schema is broader than microkernel caps, use an **overlay wrapper** located in `runtime/spec/min/` that narrows fields via `allOf`.

### `lens.define`

- **Payload schema:** `runtime/spec/lens.define_payload.json`
- **Result schema:**  `runtime/spec/lens.define_result.json`

> If you need tighter caps than the existing schema, add:
>
> `runtime/spec/min/lens.define_payload.min.json`
> ```json
> {
>   "$id": "runtime/spec/min/lens.define_payload.min.json",
>   "allOf": [
>     { "$ref": "../lens.define_payload.json" },
>     {
>       "type": "object",
>       "properties": {
>         "terms": { "minItems": 1, "maxItems": 6 }
>       },
>       "additionalProperties": false
>     }
>   ]
> }
> ```
> `runtime/spec/min/lens.define_result.min.json` similarly narrows `definitions` length, etc.

### `lens.check`

- **Payload schema:** `runtime/spec/lens.check_payload.json`
- **Result schema:**  `runtime/spec/lens.check_result.json`

> Optional overlay (if needed):
>
> `runtime/spec/min/lens.check_payload.min.json`
> ```json
> {
>   "$id": "runtime/spec/min/lens.check_payload.min.json",
>   "allOf": [
>     { "$ref": "../lens.check_payload.json" },
>     {
>       "type": "object",
>       "properties": {
>         "assumption": { "minLength": 3, "maxLength": 256 },
>         "method": { "enum": ["contrast","example","edge","proxy","other"] }
>       },
>       "additionalProperties": false
>     }
>   ]
> }
> ```

### `lens.trace`

- **Payload schema:** `runtime/spec/lens.trace_payload.json`
- **Result schema:**  `runtime/spec/lens.trace_result.json`

> Optional overlay:
>
> `runtime/spec/min/lens.trace_payload.min.json`
> ```json
> {
>   "$id": "runtime/spec/min/lens.trace_payload.min.json",
>   "allOf": [
>     { "$ref": "../lens.trace_payload.json" },
>     {
>       "type": "object",
>       "properties": { "steps": { "minimum": 2, "maximum": 4 } },
>       "additionalProperties": false
>     }
>   ]
> }
> ```

### `lens.refuse`

- **Payload schema:** `runtime/spec/lens.refuse_payload.json`
- **Result schema:**  `runtime/spec/lens.refuse_result.json`

> Optional overlay to enforce microkernel doctrine â€œone forward pathâ€ and reason enums:
>
> `runtime/spec/min/lens.refuse_payload.min.json`
> ```json
> {
>   "$id": "runtime/spec/min/lens.refuse_payload.min.json",
>   "allOf": [
>     { "$ref": "../lens.refuse_payload.json" },
>     {
>       "type": "object",
>       "required": ["reason","forward_route"],
>       "properties": {
>         "reason": {
>           "enum": [
>             "safety_risk","privacy_risk","policy_block",
>             "unsupported_scope","insufficient_info","other"
>           ]
>         },
>         "forward_route": {
>           "type": "object",
>           "required": ["label","suggestion"],
>           "additionalProperties": false
>         }
>       },
>       "additionalProperties": false
>     }
>   ]
> }
> ```

---

## Failure Modes

| condition                 | emission code  |
|--------------------------|----------------|
| Invalid payload          | `E_PAYLOAD`    |
| Unknown lens id          | `E_NAMESPACE`  |
| Attempt to mutate state  | `E_INVARIANT`  |

---

## Registration (tool index)

Register only these four ids under `lens.*` in `runtime/spec/tool.index.json`.  
If you use the **min overlays**, point the routerâ€™s per-tool schema pointers at the **min** files; otherwise point them at the baseline files.

## Notes on versioning

- Keep `$id` stable; bump only when changing semantics or caps.  
- Prefer **overlay min-files** to forking the baseline schemas; it keeps the â€œtruthâ€ centralized and the microkernel constraints explicit.  
- If a baseline schema is already narrow enough, skip overlays and point directly to it.

---
id: potm.kernel.micromoves.v1_6_dev
title: "35_micromoves"
display_title: "Atomic Diagnostic Moves"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >-
  Defines the smallest actionable diagnostic moves. Each micro-move has a
  deterministic trigger, input schema, and output schema. They can be chained
  to form higher-level tool-chains without side-effects.
author: practitioner
license: CC0-1.0
---

# Atomic Diagnostic Moves

## Overview

Micro-moves are the kernelâ€™s atomic diagnostic operations.  

Each micro-move is defined by:

- **id:** snake_case name  
- **trigger:** detection pattern in input or state  
- **input:** required fields  
- **output:** deterministic, minimal artifact  

Micro-moves perform no I/O, mutate only `meta_locus`, and emit a single `tool.result` signal.

---

## Move Catalog

| id          | purpose                            | trigger condition                  |
|-------------|------------------------------------|------------------------------------|
| align_scan  | detect aim/sample misalignment     | aim vs. last response mismatch     |
| zone_check  | surface relational friction        | repeated deflect/defend loops      |
| drift_check | identify topic drift               | thread diverges from initial aim   |
| fracture    | diagnose containment-worthy breach | beacon failure or constraint breach|
| quick_ref   | provide quick reference summary    | explicit â€œrecapâ€ request           |
| contrast    | highlight key differences          | comparing two or more items        |
| sandbox     | test speculative change safely     | â€œwhat ifâ€ scenario invoked         |

---

## Move Specifications

### align_scan

- **trigger:** practitioner aim differs from last kernel output  
- **payload schema:** `runtime/spec/move.align_scan_payload.json`  
- **result schema:** `runtime/spec/move.align_scan_result.json`  
- **examples:** `runtime/examples/move_align_scan_invoke.json`, `runtime/examples/move_align_scan_result.json`  
- **emit:** `tool.result { id: "move.align_scan", output: {...} }`

---

### zone\_check

* **trigger:** three or more consecutive deflect/defend signals  
* **payload schema:** `runtime/spec/move.zone_check_payload.json`  
* **result schema:** `runtime/spec/move.zone_check_result.json`  
* **examples:** `runtime/examples/move_zone_check_invoke.json`, `runtime/examples/move_zone_check_result.json`  
* **emit:** `tool.result { id: "move.zone_check", output: {...} }`

---

### drift_check

* **trigger:** topic shift detected against `meta_locus.aim`  
* **payload schema:** `runtime/spec/move.drift_check_payload.json`  
* **result schema:** `runtime/spec/move.drift_check_result.json`  
* **examples:** `runtime/examples/move_drift_check_invoke.json`, `runtime/examples/move_drift_check_result.json`  
* **emit:** `tool.result { id: "move.drift_check", output: {...} }`

---

### fracture

* **trigger:** any core beacon failure  
* **payload schema:** `runtime/spec/move.fracture_payload.json`  
* **result schema:** `runtime/spec/move.fracture_result.json`  
* **examples:** `runtime/examples/move_fracture_invoke.json`, `runtime/examples/move_fracture_result.json`  
* **emit:** `tool.result { id: "move.fracture", output: {...} }`

---

### quick\_ref

* **trigger:** explicit `recap` request or after closure  
* **payload schema:** `runtime/spec/move.quick_ref_payload.json`  
* **result schema:** `runtime/spec/move.quick_ref_result.json`  
* **examples:** `runtime/examples/move_quick_ref_invoke.json`, `runtime/examples/move_quick_ref_result.json`  
* **emit:** `tool.result { id: "move.quick_ref", output: {...} }`

---

### contrast

* **trigger:** two or more items provided for comparison  
* **payload schema:** `runtime/spec/move.contrast_payload.json`  
* **result schema:** `runtime/spec/move.contrast_result.json`  
* **examples:** `runtime/examples/move_contrast_invoke.json`, `runtime/examples/move_contrast_result.json`  
* **emit:** `tool.result { id: "move.contrast", output: {...} }`

---

### sandbox

* **trigger:** practitioner requests hypothetical exploration  
* **payload schema:** `runtime/spec/move.sandbox_payload.json`  
* **result schema:** `runtime/spec/move.sandbox_result.json`  
* **examples:** `runtime/examples/move_sandbox_invoke.json`, `runtime/examples/move_sandbox_result.json`  
* **emit:** `tool.result { id: "move.sandbox", output: {...} }`

---

## Sequencing & Composition

* Micro-moves may be invoked in sequence by the router or by higher-level lenses.
* Each move emits exactly one `tool.result` and may update `meta_locus`.
* No move reads or writes external data; all state changes are session-local.

---

## Annex & References

* **router contract:** `40_router.md`
* **lenses overview:** `30_lenses.md`
* **validator rules:** `60_validator.md`

```
---
---
id: potm.kernel.router.v1_6_dev
title: "40_router"
display_title: "Router â€” Invocation Grammar & Dispatch"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >-
  Defines a strictly schema-guarded envelope, explicit namespace allow-list,
  deterministic dispatch algorithm, idempotency via request_id, and a unified
  emission contract. Fail-closed by default; pure function of input.
author: practitioner
license: CC0-1.0
---

## Router â€” Invocation Grammar & Dispatch

The kernel executes only structured calls. Plain text is inert.  
Adapters may translate human input into structured calls; the kernel never  
infers intent from prose.

- scope: session-local only  
- I/O: none (no network, no filesystem)  
- determinism: true (pure function of input)  
- failure mode: fail-closed  

---

### Canonicalization (normative)

All router caches MUST use the canonical form above when comparing payloads for
idempotency. Implementations MAY store `digest` alongside `request_id`.

> The router **strips unknown keys inside `tool.call.meta`** prior to envelope
> validation to prevent adapter meta-leakage. All other unknown fields fail-closed.
>
> The full envelope schema is externalized:  
> **see `runtime/spec/router_envelope.json`**

The router validates every call against this schema before further dispatch.

---

## Global Caps (P1)

- Envelope size â‰¤ 8 KB  
- Payload depth â‰¤ 3; object keys â‰¤ 64 chars; arrays â‰¤ 32 items  
- String field length â‰¤ 2 KB (per field)  

---

## Namespaces (allow-list)

Only these namespaces are executable. Unknown â†’ `tool.error` `{ code: "E_NAMESPACE" }`.

```
lens.*       # diagnostic lenses
move.*       # atomic micro-moves
closure.*    # closure tools
recap.*      # recap.spec
policy.*     # policy.query / enforce / report
glyph.*      # glyph invocations
guardian.*   # guardian triggers
```

> **Out of kernel (interpretive/adapters):** `menu.*`, `ack.*`, exporters.  
> **Reserved (add later if specced minimally):** invokable `beacon.*` tools. Beacons may log signals but are not router targets.

---

## Tool Index (session-local registry)

Router dispatches only to tools registered here. Missing â†’ `tool.error` `{ code: "E_TOOL" }`.

Externalized registry: `runtime/spec/tool.index.json`

Fracture moves (registered): `move.open_fracture`, `move.review_fracture`, `move.close_review`.

Each payload/result schema must set `additionalProperties:false` and define numeric/string caps. `tool.index` is immutable for the session.

---

## Dispatch Algorithm (deterministic)

1. Validate envelope against `potm.kernel.router.envelope.v1`.  
2. Split `id` â†’ `{namespace, name}`; verify namespace in allow-list.  
3. Lookup full `id` in `tool.index`.  

4. **Run validator chain (P1):**
   - **latency.validator** (always)
     * Ensures `meta_locus.latency_mode` is valid.
     * Enforces fast-path invariant per mode.
     * Checks observed latency against `policy.cap.latency[mode].p95`.
     * Emits `E_LATENCY_MODE`, `E_LATENCY_INVARIANT`, `W_LATENCY_EXTRA`, `W_LATENCY_BREACH`, or `W_LATENCY_FALSE_BREACH`.

   - **recap.validator** (only when `id == recap.spec`)
     * Enforces recap payload schema (`include`, `max_items`, `max_words_line`).
     * Caps checked against `policy.cap.recap`.
     * Emits `E_PAYLOAD` on any schema violation.
     * Export guard is handled by `policy.targets: recap.export`.

   > Ordering is strict: latency first, then tool-specific validators, then the tool itself.  
   > If any validator fails, dispatch halts and only the first error is emitted.  

5. Validate `payload` against the toolâ€™s schema; enforce global caps.  
6. Check preconditions (session flags like `agreement.accepted`).  
7. Idempotency:
   - Compute `digest := SHA256(canonical(id,payload))` where `canonical`:
     â€¢ lowercases namespace/name; â€¢ sorts object keys lexicographically at all depths;  
     â€¢ strips insignificant whitespace; â€¢ preserves array order.
   - If `request_id` seen with *same* `digest` â†’ return cached emission.  
   - If `request_id` seen with *different* `digest` â†’  
     `tool.error { code:"E_INVARIANT", reason:"request_id_reuse_mismatch" }`.  

8. Execute tool (pure, no side-effects).  
9. Emit `tool.emit` or `tool.error` (see Emissions Contract).  

`meta.trace` does not affect behavior, only whether debug frames appear in the emission.

---

## Emissions Contract

> The full emissions schema is externalized:  
> **see `runtime/spec/router_emission.json`**

Router emissions must conform exactly; unspecified fields are rejected.

---

## Examples

**Valid call** â€” see `runtime/examples/recap_spec_invoke.json`

**Fracture moves** â€” router calls:  
- Open: `runtime/examples/fracture_open.json`  
- Review: `runtime/examples/fracture_review.json`  
- Resolve: `runtime/examples/fracture_resolve.json`

**Glyphs** â€” router call & result:  
- Invoke: `runtime/examples/glyph_invoke.json`  
- Result: `runtime/examples/glyph_result.json`
  
Ledger (glyph events):  
- `runtime/examples/glyph_invoke_ledger.json`  
- `runtime/examples/glyph_result_ledger.json`  
- `runtime/examples/glyph_map_ledger.json`

**Guardian** â€” router call & result:  
- Trigger (soft): `runtime/examples/guardian_trigger_soft.json`  
- Trigger (hard): `runtime/examples/guardian_trigger_hard.json`  
- Result: `runtime/examples/guardian_trigger_result.json`  
  
Ledger (guardian events):  
- `runtime/examples/guardian_soft_ledger.json`  
- `runtime/examples/guardian_hard_ledger.json`

**Externalist** â€” router call & result:
- Invoke: `runtime/examples/externalist_invoke.json`  
- Result: `runtime/examples/externalist_result.json`  
  
Ledger (externalist events):  
- `runtime/examples/externalist_ledger.json`

---

## Router Notes

- Glyph actions (invoke, result, map) MUST log a `glyph_event` ledger entry.  
  Schema: `runtime/spec/ledger.glyph_event.json` (capacity bound by `policy.cap.ledger_max`).

- Fracture diagnostics ("Fracture Finder" workflows) live under `extended/diagnostics/fracture/`  
  and are practitioner-facing protocols, not router tools. Router exposes only  
  the fracture queue moves (e.g., `move.open_fracture`, `move.review_fracture`, `move.close_review`).

- BS-Detect and Sentinel Spotcheck are practitioner diagnostics (session-local) and not router tools.  
  Results and ledger entries are documented under:  
  - `runtime/spec/bs_detect_result.json`, `runtime/spec/ledger.bs_detect_event.json`  
  - `runtime/spec/sentinel_spotcheck.json`, `runtime/spec/ledger.spotcheck_event.json`

**Rejected (unknown namespace)** â€” see `id` pattern in `runtime/spec/router_envelope.json`

---

## Failure Modes & Counters (P1)

- Schema drift â†’ schemas versioned & pinned in `tool.index`  
- Adapter meta leakage â†’ router strips unknown meta keys before validation  
- Replay storms â†’ session cache keyed by `request_id` (LRU â‰¤ 128)  
- Caps evasion â†’ router enforces global caps before tool validation  
- Ambiguous tool id â†’ strict `id` pattern + allow-list  

## Latency Validation Hook

Before emitting any routed output, the router must invoke the validatorâ€™s
latency check (see `60_validator.md`). This ensures contract (85) is enforced
in-flow.

```pseudo
result = validator.latency_check()

if result == error:
    halt
    emit kernel.error { code: "E_LATENCY_INVARIANT" }
elif result == warning:
    emit [LATENCY WARNING] + normal response
else:
    continue â†’ normal emission

---

## Versioning & Change Log

- 1.6.0-dev: Introduce envelope/emission schemas, namespace allow-list,  
  idempotency, fixed dispatch order, global caps enforcement, fail-closed defaults.  
```
---
id: potm.kernel.micro_canary.v1_0
title: "67_micro_canary"
display_title: "Micro-Canary â€” Early Anomaly Sensor"
type: kernel
lifecycle: canon
version: 1.0.0
status: active
stability: core
summary: >-
  Provides lightweight anomaly detection before hard invariants are breached.  
  The micro-canary emits soft warnings into the ledger, escalates only via  
  escalation gates, and tunes its sensitivity according to the active mode profile.
author: practitioner
license: CC0-1.0
---

# Micro-Canary â€” Early Anomaly Sensor

## Purpose

The micro-canary functions as an **early warning system**.  
Where validators enforce hard schema or cap failures, the canary watches for **softer anomalies**:  
unexpected patterns, near-misses, or repeated weak signals that often precede failure.

Its purpose is not to halt execution, but to *chirp early* and feed escalation gates with enough signal to prevent silent drift.

---

## Detection Categories

- **Schema near-miss**  
  Inputs structurally valid but suspicious (e.g. repeated optional fields missing).  

- **Unusual latency pattern**  
  Spikes that donâ€™t breach hard caps but deviate significantly from baseline.  

- **Drift pattern**  
  Repeated small deviations that alone are benign but collectively concerning.  

- **Unknown/other**  
  Anomalies not covered but surfaced by external diagnostic lenses.

---

## Sensitivity (Profile-Tuned)

| Profile   | Sensitivity            | Chirp Threshold |
|-----------|------------------------|-----------------|
| Lite      | Low â€” alert only on repeated anomalies | 3 consecutive |
| Standard  | Medium â€” chirp on pattern deviation   | 2 consecutive |
| Strict    | High â€” chirp on single anomaly        | 1 event       |

Sensitivity is bound to `mode_profile` (see `65_mode_profiles.md`).  

---

## Outputs

- **Ledger entry** of type `canary_report` with fields:  
  - `signal`: enum {schema_near_miss, unusual_latency, drift_pattern, unknown}  
  - `severity`: {warning|error}  
  - `mode_profile`: profile active at time of detection  
  - `ts`: ISO-8601 timestamp  

- **Escalation gates** may consume canary outputs to trigger mode escalation or fracture creation.

---

## Switching Logic

- Canary emits only **soft warnings**; it never halts flow.  
- Escalation gates interpret frequency/severity.  
- Can be temporarily silenced by policy (`policy.cap.canary_squelch = true`).  

---

## Failure Modes

| Condition                     | Counter-measure                       |
|-------------------------------|---------------------------------------|
| False positives (noise)       | Squelch via policy cap; tune severity |
| Silent canary (no emission)   | Covered by structural audit protocol  |
| Overload (spam emissions)     | Gate by `policy.cap.ledger_max`       |

---

### Cross-Reference â€” Enforcement in State

Validation of `canary.report` payloads and errors is enforced in `70_state.md`.

- Invalid `signal` â†’ `E_CANARY_SIGNAL`  
- Invalid `severity` â†’ `E_CANARY_SEVERITY`  
- Missing required field â†’ `E_PAYLOAD`  

See **Failure Modes (errors)** in `70_state.md` for the canonical table.

---

## References

* Profiles: `65_mode_profiles.md`  
* State locus: `70_state.md`  
* Escalation gates: `68_escalation_gates.md` (forthcoming)  
* Policy integration: `90_policy.md`  

---

## Versioning & Change Log

* **1.0.0** â€” Initial spec. Introduces anomaly categories, profile-tuned sensitivity, and ledger reporting.
---
id: potm.kernel.state.v1_6_dev
title: "70_state"
display_title: "State â€” Session State & Locus"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >-
  Defines the session-local state model, including `meta_locus` and the in-
  memory ledger buffer. All state is deterministic, in-memory, and read/write
  via explicit kernel moves.
author: practitioner
license: CC0-1.0
---

## Overview

Session state is purely in-memory and scoped to the current session.  
The kernel treats state as an explicit contract: tools may read or write  
only via defined lenses or moves. No background I/O or filesystem writes.

- scope: session-local only  
- I/O: none  
- determinism: true (state is a pure function of moves)  
- failure mode: fail-closed (invalid updates are rejected)  

---

## State Components

1. meta_locus  
2. ledger_buffer  

### meta_locus

Holds session flags and the fracture review queue used for gating and diagnostics.  

See:  
- `runtime/examples/state_meta_locus.json`  
- `runtime/examples/state_accept_entry.json`  
- `runtime/examples/state_open_fracture.json`

Notes:  
- `latency_mode` is enforced specifically by the latency validator (`85_latency_validator.md`).  
- `mode_profile` is the higher-level envelope: it governs validator strictness, escalation gates, and micro-canary sensitivity in addition to latency ceilings.  
- In most cases, `mode_profile` and `latency_mode` will share the same value, but they are kept distinct to preserve clarity of responsibility.  

- additionalProperties: false  
- initial state:
  - accepted: true  
  - containment: false  
  - review_queue: []            # array of fractureId strings only  
  - latency_mode: standard  
  - mode_profile: standard  

- review_queue semantics:
  - Stores fractureId strings only (lightweight queue).  
  - Full entries are kept in a session-local `fracture_log` map keyed by fractureId.  
  - Fracture entries conform to `runtime/schema/fracture_entry.json`.  
  - See examples:
    - open: `runtime/examples/fracture_open.json` (invokes `move.open_fracture`)
    - review: `runtime/examples/fracture_review.json` (invokes `move.review_fracture`)
    - resolve: `runtime/examples/fracture_resolve.json` (invokes `move.close_review`)

 #### Invariants

- `accepted` is true by default. It may still be reset by `[KERNEL_EXIT]`.  
- `containment` may enable only if `len(review_queue) > 0`; auto-disable when queue becomes empty.  
- `latency_mode` must always be one of {lite, standard, strict}; default is `standard`.  

---

### ledger_buffer

A chronological, in-memory array of lightweight ledger entries recording artifacts, moves, and optional exports.  

See:  
- `runtime/examples/state_ledger_buffer.json`  
- `runtime/examples/state_record_latency_breach.json`  
- `runtime/examples/state_set_latency_mode.json`  
- `runtime/examples/state_log_latency_breach.json`  
- `runtime/examples/state_set_mode_profile.json`  
- `runtime/examples/state_record_mode_profile_change.json`  
- `runtime/examples/state_record_canary_report.json`  
- `runtime/examples/state_escalation_tier2.json`  
- `runtime/examples/state_escalation_tier3_fracture.json`  
- `runtime/examples/state_escalation_tier4_containment.json`  
- `runtime/examples/state_escalation_quota_exceeded.json`

- additionalProperties: false  
- max length: session-cap (see `90_policy.md`)  
- entries expire only at session end  

---

### fracture_log

Session-local map of fracture entries keyed by `fracture_id`.  
All entries conform to `runtime/schema/fracture_entry.json`.  
The `review_queue` stores ids only; full entries live here.  

---

## Read & Write Access (tools)

Tools interact with state only via these contracts:

| Operation          | Tool namespace            | Effect                                                         |
| ------------------ | ------------------------- | -------------------------------------------------------------- |
| Read meta_locus    | lens.locus_status         | Returns full `meta_locus` snapshot                             |
| Read latency state | lens.latency_status       | Returns current `latency_mode` and most recent breach metadata |
| Accept entry       | move.accept_entry         | Sets `accepted=true` (one-way)                                 |
| Set containment    | move.set_containment      | Sets `containment` under invariants and policy cap             |
| Set latency mode   | move.set_latency_mode     | Sets `latency_mode` under invariants                           |
| Enqueue review     | move.open_fracture        | Records entry in `fracture_log`; appends fractureId to `review_queue` |
| Mark review        | move.review_fracture      | Sets entry `status: review` in `fracture_log`                  |
| Dequeue review     | move.close_review         | Sets `status: resolved` in `fracture_log`, removes id; auto-disables containment if queue empty |
| Append ledger      | move.record_ledger        | Appends entry to `ledger_buffer`                               |
| Log latency breach | move.log_latency_breach   | Appends structured `latency_breach` entry to `ledger_buffer`   |

All write operations validate against invariants and fail-closed on violations.

---

## Behavior (latency_status lens)

**mode** â†’ always returns the current value of `meta_locus.latency_mode`.  

**last_breach** â†’  
- `null` if no breaches recorded  
- otherwise returns the most recent `latency_breach` entry in `ledger_buffer`, including:  
  - `ts` (timestamp)  
  - `observed_latency`  
  - `ceiling`  
  - `severity` (`warning|error`)  

See:  
- `runtime/examples/state_log_latency_breach.json`

---

## Containment gating

When `meta_locus.containment=true`, only containment-mode tools are available  
(see `76_containment_mode.md`). Non-containment mutations fail-closed.  
Containment integrates with Tier 3/4 escalation and the fracture queue; review  
continues under containment until resolved or exited via grace path.

## Ledger entries (specs)

- Fracture events: `runtime/spec/ledger.fracture_event.json`  
- Containment events: `runtime/spec/ledger.containment_event.json`
- Zuihitsu glyph events: `runtime/spec/ledger.glyph_zuihitsu_event.json`
- Glyph events: `runtime/spec/ledger.glyph_event.json`  
- Guardian events: `runtime/spec/ledger.guardian_event.json`  
 - Mode profile changes: `runtime/spec/ledger.mode_profile_change.json`  
 - Latency breaches: `runtime/spec/ledger.latency_breach.json`  
 - Closure events: `runtime/spec/ledger.closure_event.json`  
 - Policy events: `runtime/spec/ledger.policy_event.json`  
- Escalation events: `runtime/spec/ledger.escalation_event.json`  
- BS-Detect events: `runtime/spec/ledger.bs_detect_event.json`  
- Spotcheck events: `runtime/spec/ledger.spotcheck_event.json`  

## Failure Modes (errors)

| Condition                                      | Emission                                     |
| ---------------------------------------------- | -------------------------------------------- |
| Attempt to reset `accepted` true â†’ false       | `tool.error { code: "E_INVARIANT" }`        |
| Enable `containment` when queue empty          | `tool.error { code: "E_PRECONDITION" }`      |
| Invalid `review_queue` item type               | `tool.error { code: "E_INVARIANT" }`         |
| Ledger append when buffer full                 | `tool.error { code: "E_QUOTA" }`             |
| Invalid `mode` not in {lite, standard, strict} | `tool.error { code: "E_LATENCY_MODE" }`      |
| Negative or non-numeric latency                | `tool.error { code: "E_PAYLOAD" }`           |
| Severity not in {warning, error}               | `tool.error { code: "E_LATENCY_INVARIANT" }` |
| `latency_mode` missing/invalid                 | `tool.error { code: "E_LATENCY_MODE" }`      |
| Invalid `mode_profile` not in {lite, standard, strict} | `tool.error { code: "E_MODE_PROFILE" }`     |
| Drift (mode_profile vs latency_mode mismatch)  | `tool.error { code: "E_INVARIANT" }`        |
| Ledger empty / no breaches                     | `{ "mode": <current>, "last_breach": null }` |
| Invalid `signal` not in {schema_near_miss, unusual_latency, drift_pattern, unknown} | `tool.error { code: "E_CANARY_SIGNAL" }`   |
| Invalid `severity` not in {warning, error}                                          | `tool.error { code: "E_CANARY_SEVERITY" }` |
| Missing required field in canary.report payload                                     | `tool.error { code: "E_PAYLOAD" }`         |
| Canary ledger quota exceeded                    | `tool.error { code: "E_CANARY_QUOTA" }`      |
| Invalid `tier` not in {1,2,3,4}                 | `tool.error { code: "E_ESCALATION_TIER" }`   |
| Invalid `action` not in {none, escalate_profile, fracture_trigger, containment} | `tool.error { code: "E_ESCALATION_ACTION" }` |
| Source not in {validator, latency, canary, policy, other} | `tool.error { code: "E_ESCALATION_SOURCE" }` |
| Escalation quota exceeded (too many escalation_event entries) | `tool.error { code: "E_ESCALATION_QUOTA" }`  |
| Escalation ledger empty / no events             | { "last_source": null, "last_tier": null, "last_action": null, "mode_profile": <current>, "last_change": null, "history_count": 0 } |
| Invalid escalation record shape (schema drift)  | `tool.error { code: "E_ESCALATION_RECORD" }`  |

---

## Examples

Examples are externalized. See canonical instances in `runtime/examples/`:

- `state_meta_locus.json` â€” default snapshot  
- `state_accept_entry.json` â€” entry gate accepted  
- `fracture_open.json` â€” fracture created via move; queued  
- `fracture_review.json` â€” fracture moved to review  
- `fracture_resolve.json` â€” fracture resolved and dequeued  
 - `fracture_open_result.json` â€” confirmation of queue (status: queued)  
 - `fracture_review_result.json` â€” confirmation of review (status: review)  
 - `fracture_resolve_result.json` â€” confirmation of resolution (status: resolved)  
- `state_record_latency_breach.json` â€” latency breach entry  
- `state_set_latency_mode.json` â€” switch to lite  
- `state_log_latency_breach.json` â€” breach logged + lens output  
- `state_set_mode_profile.json` â€” profile manual override  
- `state_read_mode_profile.json` â€” lens output for profile  
- `state_record_mode_profile_change.json` â€” profile change event  
- `state_record_canary_report.json` â€” canary emission  
- `state_canary_status.json` â€” last canary status lens  
- `state_escalation_tier2.json` â€” Tier 2 escalation  
- `state_escalation_tier3_fracture.json` â€” Tier 3 escalation  
- `state_escalation_tier4_containment.json` â€” Tier 4 escalation  
- `state_escalation_status.json` â€” escalation status lens  
- `state_escalation_quota_exceeded.json` â€” quota exceeded case  
- `containment_invoke.json` â€” enter containment (move.set_containment)  
- `containment_exit.json` â€” exit containment (move.set_containment)  
 - `containment_enter_result.json` â€” confirmation of containment entry  
- `containment_exit_result.json` â€” confirmation of containment exit  

### Glyph Examples

- `glyph_invoke.json` â€” invoke a glyph  
- `glyph_result.json` â€” glyph result payload  
- `glyph_invoke_ledger.json` â€” ledger entry for glyph invoke  
- `glyph_result_ledger.json` â€” ledger entry for glyph result  
- `glyph_map_ledger.json` â€” ledger entry for resonance mapping  

### Lens Examples

- `lens_fracture_status.json` â€” snapshot of fracture queue & containment flag  

### Ledger Examples

- `fracture_open_ledger.json` â€” ledger entry for fracture open  
- `fracture_review_ledger.json` â€” ledger entry for fracture review  
- `fracture_resolve_ledger.json` â€” ledger entry for fracture resolve  
- `containment_enter_ledger.json` â€” ledger entry for containment enter  
- `containment_exit_ledger.json` â€” ledger entry for containment exit  
 - `containment_abort_ledger.json` â€” ledger entry for containment abort  
 - `latency_breach_ledger.json` â€” ledger entry for latency breach  
 - `escalation_tier2_ledger.json` â€” ledger entry for Tier 2 escalation  
 - `escalation_tier3_ledger.json` â€” ledger entry for Tier 3 escalation  
 - `escalation_tier4_ledger.json` â€” ledger entry for Tier 4 escalation  
 - `mode_profile_change_ledger.json` â€” ledger entry for mode profile change  
 - `closure_archive_ledger.json` â€” ledger entry for closure.archive  
 - `closure_spiral_ledger.json` â€” ledger entry for closure.spiral  
 - `closure_waiting_with_ledger.json` â€” ledger entry for closure.waiting_with  
 - `policy_query_ledger.json` â€” ledger entry for policy.query  
 - `policy_enforce_ledger.json` â€” ledger entry for policy.enforce  
- `bs_detect_ledger.json` â€” ledger entry for bs_detect  
- `sentinel_spotcheck_ledger.json` â€” ledger entry for sentinel_spotcheck  

### Externalist Examples

- `externalist_invoke.json` â€” externalist invoke (diagnostic overlay)  
- `externalist_result.json` â€” externalist result with reframed question  
- `externalist_ledger.json` â€” ledger entry for externalist event  

### Guardian Examples

- `guardian_trigger_soft.json` â€” soft guardian trigger  
- `guardian_trigger_hard.json` â€” hard guardian trigger  
- `guardian_trigger_result.json` â€” result confirmation  
- `guardian_soft_ledger.json` â€” ledger entry for soft trigger  
- `guardian_hard_ledger.json` â€” ledger entry for hard trigger  

## Externalist moves (specs)

- externalist.invoke â€”  
  - payload: `runtime/spec/externalist.invoke_payload.json`  
  - result:  `runtime/spec/externalist.result.json`

---

## Fracture resources (diagnostics)

For practitioner diagnostics and review heuristics, see:  
- `extended/diagnostics/fracture/fracture_finder.md`  
- `extended/diagnostics/fracture/fracture_finder_playbook.md`  
- `extended/diagnostics/fracture/fracture_crosswalk.md`  
- `meta/fracture_meta`  

## Practitioner Protocols

- mirror_protocol â€” `kernel/protocols/mirror_protocol.md`  
- suspicion_first_protocol â€” `kernel/protocols/suspicion_first_protocol.md`  
- ai_integrity_protocol â€” `kernel/protocols/ai_integrity_protocol.md`  

## Fracture moves (specs)

- move.open_fracture â€”  
  - payload: `runtime/spec/move.open_fracture_payload.json`  
  - result:  `runtime/spec/move.open_fracture_result.json`
- move.review_fracture â€”  
  - payload: `runtime/spec/move.review_fracture_payload.json`  
  - result:  `runtime/spec/move.review_fracture_result.json`
- move.close_review â€”  
  - payload: `runtime/spec/move.close_review_payload.json`  
  - result:  `runtime/spec/move.close_review_result.json`

## Containment moves (specs)

- move.set_containment â€”  
  - payload: `runtime/spec/move.set_containment_payload.json`  
  - result:  `runtime/spec/move.set_containment_result.json`
- containment.abort â€”  
  - payload: `runtime/spec/containment.abort_payload.json`  
  - result:  `runtime/spec/containment.abort_result.json`

---

### ðŸ”‘ Notes for practitioners

* `move.set_mode_profile` changes `meta_locus.mode_profile`, records timestamp + source.  
* `lens.mode_profile_status` is **read-only** â€” safe to call any time.  
* Default on entry is `"standard"` unless overridden in the handshake.  

---

## Notes & References

* Entry gate and gating logic: `10_entry_gate.md`  
* Moves & lenses: `30_lenses.md`, `35_micromoves.md`  
* Policy & quota: `90_policy.md`  
* Recap spec (reads state): `50_recap_spec.md`  
---
-## Glyph moves (specs)

- glyph.invoke â€”  
  - payload: `runtime/spec/glyph.invoke_payload.json`  
  - result:  `runtime/spec/glyph.result.json`
---
id: potm.kernel.guardian_mode.v1_6_dev
title: "78_guardian_mode"
display_title: "Guardian â€” Sentinel Overlay"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >-
  Defines Guardian as a sentinel overlay on state and escalation. Monitors
  session signals, evaluates triggers (soft/hard), and hands off to
  escalation/containment when necessary.
author: practitioner
license: CC0-1.0
---

## Purpose

Guardian is an always-on safety sentinel. It runs in parallel with normal
kernel operation to detect destabilization, ethical heat, or threat to
integrity. Guardian never diagnoses; it routes.

---

## Lifecycle

1) Monitor  
   - Ambient checks against trigger conditions.  
   - Harmonizes with validators and canary signals.  

2) Trigger Evaluation  
   - `severity: soft` â†’ record + watch; may elevate to Tier 2 depending on context.  
   - `severity: hard` â†’ immediate elevation (Tier 3/4) via escalation gates.  

3) Handoff  
   - Tier 2â€“3 â†’ escalate profile and/or open fracture (see `68_escalation_gates.md`).  
   - Tier 4 â†’ enter containment (see `76_containment_mode.md`).  

All actions must log ledger entries (`guardian_event`).

---

## Tools (allow-list)

- `guardian.trigger`  
  - Payload: `runtime/spec/guardian.trigger_payload.json`  
  - Result:  `runtime/spec/guardian.trigger_result.json`

---

## Failure Modes

- Invalid trigger payload â†’ `E_PAYLOAD`  
- Quota exceeded (`policy.cap.guardian_max`) â†’ `E_QUOTA`  
- Recursive invocation (during active trigger handling) â†’ `E_INVARIANT`  

---

## Pointers

- Payload/Result schemas:  
  - `runtime/spec/guardian.trigger_payload.json`  
  - `runtime/spec/guardian.trigger_result.json`
- Ledger entry schema: `runtime/spec/ledger.guardian_event.json`  
- Escalation gates: `kernel/68_escalation_gates.md`  
- Containment integration (Tier 4): `kernel/76_containment_mode.md`

---
id: potm.kernel.closure.v1_6_dev
title: "80_closure"
display_title: "Closure Tools"
type: kernel
lifecycle: canon
version: 1.6.0-dev
status: active
stability: stable
summary: >-
  Defines P1 closure tools for session-level cycle operations: spiral (drift vs evolution),
  archive (final snapshot), and waiting_with (active containment). Tools are deterministic,
  session-local, and never export; any export is adapter-side and policy-gated.
author: practitioner
license: CC0-1.0
---

## Overview

Closure tools package or gate ongoing threads at the **session** level.

Provided tools (registered in `tool.index`):
- `closure.spiral`
- `closure.archive`
- `closure.waiting_with`

All are invoked via `tool.call`, read/write only session state (`70_state.md`),
and emit structured results or `tool.error` with router-aligned codes.

- scope: session-local only  
- I/O: none (no filesystem/network)  
- determinism: true (pure function of state + payload)  
- failure mode: fail-closed  

---

## Invocation

`tool.call` with `id: "closure.<tool_name>"` and payload matching schema.  

`<tool_name>` âˆˆ { `spiral`, `archive`, `waiting_with` }.  

> Envelope errors & unknown tools are handled by the router (`E_NAMESPACE` / `E_TOOL` / `E_PAYLOAD`).  

---

## Tool Schemas & Behavior

### 1) `closure.spiral` â€” drift vs evolution summary

- **Payload schema**: defined in `runtime/schema/closure_spiral.json`  
- **Result**: emits `diff_log` string (â‰¤ `policy.cap.diff_log_max`, 400 chars)  

See:  
- `runtime/examples/closure_spiral_invoke.json`  
- `runtime/examples/closure_spiral_result.json`

Ledger: `closure_event`
- Schema: `runtime/spec/ledger.closure_event.json`
- Example: `runtime/examples/closure_spiral_ledger.json`

---

### 2) `closure.archive` â€” final snapshot of a cycle

- **Preconditions**: `len(meta_locus.review_queue) == 0` (else `E_PRECONDITION`)  
- **Payload schema**: `runtime/schema/closure_archive.json`  
- **Result**: may include `summary`, `takeaways`, `archive_status`  

See:  
- `runtime/examples/closure_archive_invoke.json`  
- `runtime/examples/closure_archive_result.json`

Ledger: `closure_event`
- Schema: `runtime/spec/ledger.closure_event.json`
- Example: `runtime/examples/closure_archive_ledger.json`

---

### 3) `closure.waiting_with` â€” active containment for unresolved tensions

- **Preconditions**: `len(meta_locus.review_queue) > 0`  
- Sets `meta_locus.containment = true`; auto-clears via `70_state.md` when queue empties.  
- **Payload schema**: `runtime/schema/closure_waiting_with.json`  

See:  
- `runtime/examples/closure_waiting_with_invoke.json`  
- `runtime/examples/closure_waiting_with_result.json`

Ledger: `closure_event`
- Schema: `runtime/spec/ledger.closure_event.json`
- Example: `runtime/examples/closure_waiting_with_ledger.json`

---

## Data Annexes (read-only, optional)

* `ANNEX:FRACTURE_TAXONOMY_MINI` (P1-MIN; improves spiral wording)  

Ledger: `closure_event`
- Schema: `runtime/spec/ledger.closure_event.json`
- Example: `runtime/examples/closure_archive_ledger.json`

* Fracture Taxonomy (master): `extended/diagnostics/fracture/fracture_taxonomy_master_table.md`  
* `ANNEX:FRACTURE_CROSSWALK` (optional)  
* `ANNEX:FRACTURE_META_UNITY` (optional)  

> Annexes refine labels only; absence must not change tool behavior.  

---

## Failure Modes (router-aligned)

| condition                               | emission code    |
| --------------------------------------- | ---------------- |
| payload fails schema                    | `E_PAYLOAD`      |
| open fractures on `closure.archive`     | `E_PRECONDITION` |
| `waiting_with` without open fracture    | `E_PRECONDITION` |
| ledger buffer full during ledger append | `E_QUOTA`        |

---

## Versioning & Change Log

* **1.6.0-dev**: Initial P1 spec for `closure.spiral`, `closure.archive`, `closure.waiting_with`; router-aligned errors; state-gated preconditions; policy-gated caps; idempotent outputs.
Perfect â€” hereâ€™s a clean **`85_latency_validator.md v1.0.0`** that pulls the latency enforcement logic out of the corrupted `60_recap_validator.md` and gives it its own stable home. It follows the same kernel doc style youâ€™ve used elsewhere.

---

````markdown
---
id: potm.kernel.latency_validator.v1_0
title: "85_latency_validator"
display_title: "Latency â€” Contract Validator (P1)"
type: kernel
lifecycle: canon
version: 1.0.0
status: active
stability: stable
summary: >-
  Validates adherence to latency mode contract. Ensures mode is valid,
  checks permitted checks per mode, and enforces p50/p95 ceilings
  from `policy.cap.latency`.
author: practitioner
license: CC0-1.0
---

## Overview

This validator enforces the **latency contract** across all kernel turns.

- scope: session-local only  
- side effects: logs breaches to `ledger_buffer` via `move.log_latency_breach`  
- failure mode: fail-closed (router halts dispatch on error)  

---

## Invocation (router contract)

Payload/Result schemas externalized:
- `runtime/spec/latency.validator.payload.json`
- `runtime/spec/latency.validator.result.json`

---

## Schema (`latency_validator`)

See `runtime/spec/latency.validator.payload.json`.

* `latency_mode` must be valid.
* `observed_latency` and `ceiling` must be positive numbers.
* `severity` distinguishes warning vs. error handling.
* Ceilings are resolved from `policy.cap.latency` (p95 per mode).

---

## Contract Rules

### 1. Mode validity

```pseudo
assert meta_locus.latency_mode in {lite, standard, strict}
```

If invalid â†’
`tool.error { code: "E_LATENCY_MODE" }`

---

### 2. Fast-path invariant

* In all modes, only these checks are always allowed:

  * `agreement.accepted`
  * `validator.stub`

* Heavy checks:

  * `lite` â†’ forbidden â†’ `tool.error { code: "E_LATENCY_INVARIANT" }`
  * `standard` â†’ discouraged â†’ `tool.warn { code: "W_LATENCY_EXTRA" }`
  * `strict` â†’ permitted

---

### 3. Timing bounds

```pseudo
ceiling = policy.cap.latency[latency_mode].p95

if observed_latency > ceiling:
    if latency_mode == "lite":
        tool.error { code: "E_LATENCY_INVARIANT", detail: observed_latency }
        move.log_latency_breach { ts, mode: latency_mode,
                                  observed_latency, ceiling, severity:"error" }
    else:
        tool.warn { code: "W_LATENCY_BREACH", detail: observed_latency }
        move.log_latency_breach { ts, mode: latency_mode,
                                  observed_latency, ceiling, severity:"warning" }
```

---

## Ledger Invariants â€” Latency Breach

If a `ledger_buffer` entry has `type: latency_breach`, its `meta` must include:

```pseudo
assert mode in {lite, standard, strict}
assert is_number(observed_latency) and observed_latency > 0
assert is_number(ceiling) and ceiling > 0
assert severity in {warning, error}
```

If `observed_latency <= ceiling`:
`tool.warn { code: "W_LATENCY_FALSE_BREACH" }`

Invalid entries â†’
`tool.error { code: "E_LATENCY_INVARIANT", detail:"invalid breach entry" }`

Valid entries â†’
accepted into `ledger_buffer` via `move.log_latency_breach`.

Schema & example:  
- `runtime/spec/ledger.latency_breach.json`  
- `runtime/examples/latency_breach_ledger.json`

---

## Failure Modes (router-aligned)

| condition                             | emission code            |
| ------------------------------------- | ------------------------ |
| invalid or missing `latency_mode`     | `E_LATENCY_MODE`         |
| invariant violated in `lite` mode     | `E_LATENCY_INVARIANT`    |
| heavy check in `standard` mode        | `W_LATENCY_EXTRA`        |
| latency ceiling exceeded (warn modes) | `W_LATENCY_BREACH`       |
| false breach (â‰¤ ceiling)              | `W_LATENCY_FALSE_BREACH` |
| invalid ledger breach entry           | `E_LATENCY_INVARIANT`    |

---

## Notes

* Ceilings are authoritative in `policy.cap.latency`.
* Severity escalates only in `lite` mode.
* Logging is mandatory for transparency; every breach must yield a ledger entry.

```

---
---
id: potm.kernel.refusal_doctrine.v1_6_dev
title: 90_refusal_doctrine
display_title: "Minimal Refusal Doctrine"
type: doctrine
lifecycle: canon
version: 1.6-dev
status: active
stability: stable
summary: "In-kernel, invariant refusal grounds and emission contract used by the router."
relations:
  supersedes: [potm.kernel.policy.v1_5]
  superseded_by: []
tags: [kernel, refusal, router, beacons, ledger, safety]
author: practitioner
license: CC0-1.0
---

## Purpose
Provide the non-negotiable refusal grounds and the exact emission contract the router must use when a request violates beacons or exceeds scope.

## Refusal grounds (invariants)
- **Scope (E_SCOPE):** Request exceeds kernel/extended capabilities or asks for prohibited agent acts.
- **Dignity (E_DIGNITY):** Violates the dignity beacon (dehumanization, harassment, identity speculation).
- **Integrity (E_INTEGRITY):** Requires deception, fabrication, hidden reasoning, or policy-contradictory behavior.
- **Safety (E_SAFETY):** Risk of harm (self/other), illegal instruction, or hazardous enablement.
- **Privacy (E_PRIVACY):** Extraction of sensitive personal data beyond explicit consent or session context.

> Note: Domain- or category-specific boundaries are kept in `extended/policy/` and do not alter these invariants.

## Emission contract (schema)
When refusing, emit:

[REFUSAL]
code: <E_SCOPE|E_DIGNITY|E_INTEGRITY|E_SAFETY|E_PRIVACY>
beacon: <dignity|integrity|safety>
summary: <1â€“2 line human-readable reason>
offer: <one safe alternative, reframe, or next step>
ledger.emit: refusal(code, beacon)

The emission must be concise, practitioner-facing, and include one constructive alternative.

## Router hooks
- If signals are ambiguous or heat is high, **escalate**:
  - `guardian_mode` per kernel/78_guardian_mode.md
  - or `68_escalation_gates.md` â†’ appropriate diagnostic
- If refusal repeats on the same thread with minor variation, run `79_bs_detect.md` (pattern check).

## Policy pointers
This doctrine does **not** enumerate mutable policy. Practitioners: see `extended/policy/00_policy_index.md` for guidance, examples, and domain carve-outs.

## Versioning & lineage
- Supersedes: `potm.kernel.policy.v1_5`
- Lineage tags: `forge_origin: kernel.90_policy`, `spiral_eval: v1.6 doctrine split`

## Change log
- v1.6-dev: Split policy; retain minimal refusal + schema + hooks.

---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "beacon_event",
  "description": "Schema for beacon event entries. Used to record validator, latency, and policy signals.",
  "type": "object",
  "properties": {
    "ts": {
      "description": "Timestamp of the beacon event.",
      "type": "string",
      "format": "date-time"
    },
    "source": {
      "description": "Signal origin.",
      "type": "string",
      "enum": ["validator", "latency", "policy", "canary", "other"]
    },
    "signal": {
      "description": "Beacon signal type.",
      "type": "string",
      "enum": ["schema_near_miss", "latency_spike", "cap_breach", "drift_pattern", "unknown"]
    },
    "severity": {
      "description": "Severity of the signal.",
      "type": "string",
      "enum": ["warning", "error"]
    },
    "details": {
      "description": "Optional freeform description.",
      "type": "string",
      "maxLength": 300
    }
  },
  "required": ["ts", "source", "signal", "severity"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "closure_archive",
  "description": "Schema for closure.archive tool payload. Captures final session snapshot (summary, takeaways, archive_status).",
  "type": "object",
  "properties": {
    "summary": {
      "description": "Optional final recap or summary text.",
      "type": "string",
      "maxLength": 500
    },
    "takeaways": {
      "description": "Optional array of key takeaways.",
      "type": "array",
      "items": { "type": "string" },
      "maxItems": 10
    },
    "archive_status": {
      "description": "Optional operator note on archival state.",
      "type": "string",
      "enum": ["complete", "partial", "aborted"]
    }
  },
  "required": [],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "closure_record",
  "description": "Consensus closure scan record for meta log.",
  "type": "object",
  "properties": {
    "when": { "type": "string", "format": "date-time" },
    "thread": { "type": "string" },
    "done_definition": { "type": "string" },
    "loose_ends": {
      "type": "array",
      "items": { "type": "string" },
      "maxItems": 20
    },
    "dissent_or_unease": { "type": "string" },
    "consensus_outcome": { "type": "string", "enum": ["consensus", "defer", "escalate", "split"] },
    "center_alignment": { "type": "string", "enum": ["aligned", "misaligned", "skipped"] },
    "decisions": {
      "type": "array",
      "items": { "type": "string" },
      "maxItems": 20
    },
    "risks": {
      "type": "array",
      "items": { "type": "string" },
      "maxItems": 20
    },
    "next_trigger": { "type": "string" }
  },
  "required": ["when", "thread", "done_definition", "consensus_outcome", "center_alignment"],
  "additionalProperties": false
}

{
  "tool.call": {
    "id": "closure.spiral",
    "payload": {
      "diff_log": "Exploration drifted into meta-level; stabilized with recap.",
      "tags": ["drift", "recap"]
    }
  }
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "closure_spiral",
  "description": "Schema for closure.spiral tool payload. Summarizes drift vs evolution at end of session or cycle.",
  "type": "object",
  "properties": {
    "diff_log": {
      "description": "Optional operator-provided notes for drift vs evolution summary (will be clipped to cap).",
      "type": "string",
      "maxLength": 400
    },
    "tags": {
      "description": "Optional array of tags to classify spiral context.",
      "type": "array",
      "items": { "type": "string" },
      "maxItems": 10
    }
  },
  "required": [],
  "additionalProperties": false
}
{
  "tool.result": {
    "id": "closure.spiral",
    "output": {
      "diff_log": "Exploration drifted into meta-level; stabilized with recap.",
      "status": "completed",
      "tags": ["drift", "recap"]
    }
  }
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "closure_waiting_with",
  "description": "Schema for closure.waiting_with tool payload. Activates containment mode when unresolved fractures exist.",
  "type": "object",
  "properties": {
    "note": {
      "description": "Optional operator note on what is being waited-with.",
      "type": "string",
      "maxLength": 300
    },
    "tags": {
      "description": "Optional tags to categorize the waiting state.",
      "type": "array",
      "items": { "type": "string" },
      "maxItems": 5
    }
  },
  "required": [],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "fracture_entry",
  "description": "Schema for fracture entries queued in meta_locus.review_queue.",
  "type": "object",
  "properties": {
    "fracture_id": {
      "description": "Unique identifier for the fracture (string).",
      "type": "string"
    },
    "status": {
      "description": "Lifecycle status of the fracture entry.",
      "type": "string",
      "enum": ["open", "review", "resolved"]
    },
    "origin": {
      "description": "Origin of the fracture event.",
      "type": "string",
      "enum": ["validator", "latency", "policy", "manual"]
    },
    "details": {
      "description": "Optional diagnostic context or note.",
      "type": "string"
    },
    "ts": {
      "description": "ISO 8601 timestamp of when the fracture was recorded.",
      "type": "string",
      "format": "date-time"
    }
  },
  "required": ["fracture_id", "status", "origin"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_archive",
  "description": "Schema for the Archive lens. Summarizes or closes a thread.",
  "type": "object",
  "properties": {
    "thread": {
      "description": "The thread or topic to archive.",
      "type": "string"
    },
    "status": {
      "description": "Archival state.",
      "type": "string",
      "enum": ["complete", "partial", "aborted"]
    }
  },
  "required": ["thread"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_boundary",
  "description": "Schema for the Boundary lens. Identifies scope, limits, and thresholds.",
  "type": "object",
  "properties": {
    "topic": {
      "description": "Optional topic to boundary-check.",
      "type": "string"
    }
  },
  "required": [],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_check",
  "description": "Schema for the Check lens. Validates assumptions or premises for consistency.",
  "type": "object",
  "properties": {
    "assumption": {
      "description": "The assumption or premise to validate.",
      "type": "string"
    }
  },
  "required": ["assumption"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_contrary",
  "description": "Schema for the Contrary lens. Generates contrary or inverted statements.",
  "type": "object",
  "properties": {
    "statement": {
      "description": "The statement to invert or test contrary cases against.",
      "type": "string"
    }
  },
  "required": ["statement"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_define",
  "description": "Provide contextual definition of a term.",
  "type": "object",
  "properties": {
    "term": {
      "description": "The term to define in context.",
      "type": "string"
    },
    "context": {
      "description": "Optional short context to ground the definition.",
      "type": "string"
    }
  },
  "required": ["term"],
  "additionalProperties": false
}

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_edge",
  "description": "Surface edge cases & contradictions for a statement or topic.",
  "type": "object",
  "properties": {
    "statement": {
      "description": "The statement or claim to stress-test.",
      "type": "string"
    },
    "topic": {
      "description": "Optional topic to scope the edge scan.",
      "type": "string"
    }
  },
  "required": ["statement"],
  "additionalProperties": false
}

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_facts",
  "description": "Schema for the Facts lens. Surfaces agreed-upon facts relevant to a claim or session.",
  "type": "object",
  "properties": {
    "topic": {
      "description": "Optional topic or scope to filter facts.",
      "type": "string"
    }
  },
  "required": [],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_forge",
  "description": "Schema for the Forge lens. Crafts new synthesis or candidate formulations.",
  "type": "object",
  "properties": {
    "materials": {
      "description": "Inputs or fragments to forge into a new synthesis.",
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["materials"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_meta_conflict",
  "description": "Schema for the Meta-Conflict lens. Analyzes patterns across conflicts.",
  "type": "object",
  "properties": {
    "cases": {
      "description": "List of conflict cases to meta-analyze.",
      "type": "array",
      "items": { "type": "string" }
    },
    "focus": {
      "description": "Optional dimension of focus (values, tactics, escalation).",
      "type": "string"
    }
  },
  "required": ["cases"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_meta",
  "description": "Schema for invoking multiple lenses as a bundle, with policy hooks for anti-patterns.",
  "type": "object",
  "properties": {
    "lenses": {
      "description": "Ordered list of lens ids to invoke as a bundle.",
      "type": "array",
      "items": { "type": "string" },
      "minItems": 1,
      "uniqueItems": true
    },
    "scope": {
      "description": "Scope of invocation (session, claim, fracture).",
      "type": "string",
      "enum": ["session", "claim", "fracture"]
    },
    "policy_mode": {
      "description": "Whether to enforce anti-pattern rules strictly or advisory-only.",
      "type": "string",
      "enum": ["strict", "advisory"],
      "default": "strict"
    }
  },
  "required": ["lenses"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_open_questions",
  "description": "Surface open questions relevant to a topic or fracture.",
  "type": "object",
  "properties": {
    "topic": {
      "description": "Topic to guide open questions.",
      "type": "string"
    },
    "max_count": {
      "description": "Maximum number of questions to surface (hint-level).",
      "type": "integer",
      "minimum": 1,
      "maximum": 10
    }
  },
  "required": ["topic"],
  "additionalProperties": false
}

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_refuse",
  "description": "Schema for the Refuse lens. Marks claims or prompts as declined.",
  "type": "object",
  "properties": {
    "reason": {
      "description": "Reason for refusal.",
      "type": "string",
      "maxLength": 200
    }
  },
  "required": ["reason"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_relation_zone",
  "description": "Schema for the Relation Zone lens. Detects and reports shifts between relational zones (green, yellow, red).",
  "type": "object",
  "properties": {
    "previous": {
      "description": "The previous relational zone.",
      "type": "string",
      "enum": ["green", "yellow", "red"]
    },
    "new": {
      "description": "The new relational zone detected.",
      "type": "string",
      "enum": ["green", "yellow", "red"]
    },
    "trigger": {
      "description": "Event that caused the zone shift.",
      "type": "string",
      "enum": ["boundary_violation", "cooperation_gain", "cooperation_loss", "rupture", "repair", "other"]
    },
    "details": {
      "description": "Optional freeform description of the detected shift.",
      "type": "string",
      "maxLength": 300
    }
  },
  "required": ["previous", "new", "trigger"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_self_audit",
  "description": "Run a structured self-audit across scope.",
  "type": "object",
  "properties": {
    "scope": {
      "description": "Audit scope.",
      "type": "string",
      "enum": ["session", "kernel", "topic"]
    },
    "topic": {
      "description": "Optional topic when scope=topic.",
      "type": "string"
    }
  },
  "required": [],
  "additionalProperties": false
}

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_spiral",
  "description": "Schema for the Spiral lens. Maps growth or drift across iterations.",
  "type": "object",
  "properties": {
    "thread": {
      "description": "The thread or topic to spiral-map.",
      "type": "string"
    },
    "iterations": {
      "description": "Optional number of iterations to map.",
      "type": "integer",
      "minimum": 1,
      "maximum": 20
    }
  },
  "required": ["thread"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_synth",
  "description": "Schema for the Synthesis lens. Combines insights into a unified output.",
  "type": "object",
  "properties": {
    "inputs": {
      "description": "List of elements to synthesize.",
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["inputs"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_trace",
  "description": "Schema for the Trace lens. Follows reasoning chains step by step.",
  "type": "object",
  "properties": {
    "claim": {
      "description": "The claim or argument to trace.",
      "type": "string"
    },
    "depth": {
      "description": "Optional max depth of tracing.",
      "type": "integer",
      "minimum": 1,
      "maximum": 10
    }
  },
  "required": ["claim"],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "lens_wait",
  "description": "Schema for the Wait lens. Holds context in suspension without closure.",
  "type": "object",
  "properties": {
    "note": {
      "description": "Optional operator note on what is being held.",
      "type": "string",
      "maxLength": 200
    }
  },
  "required": [],
  "additionalProperties": false
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "recap_validator",
  "description": "Schema for validating recap.spec payloads against allowed fields and policy caps.",
  "type": "object",
  "properties": {
    "include": {
      "description": "Array of sections to include in recap output.",
      "type": "array",
      "items": {
        "type": "string",
        "enum": ["summary", "open_questions", "next_hints", "last_moves", "flags"]
      },
      "uniqueItems": true
    },
    "max_items": {
      "description": "Maximum number of recap items to include.",
      "type": "integer",
      "minimum": 1,
      "maximum": 10
    },
    "max_words_line": {
      "description": "Maximum words per recap line.",
      "type": "integer",
      "minimum": 1,
      "maximum": 50
    }
  },
  "required": ["include"],
  "additionalProperties": false
}
{
  "$id": "potm.kernel.acceptance.agreement.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Acceptance Agreement",
  "description": "Kernel entry acceptance agreement and effects.",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "token": { "type": "string", "const": "[KERNEL_ENTRY]" },
    "normalization": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "trim_whitespace": { "type": "boolean" },
        "case_sensitive": { "type": "boolean" },
        "single_line_only": { "type": "boolean" }
      },
      "required": ["trim_whitespace", "case_sensitive", "single_line_only"]
    },
    "scope": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "grants": { "type": "array", "items": { "type": "string" }, "maxItems": 16 },
        "denies": { "type": "array", "items": { "type": "string" }, "maxItems": 16 },
        "exceptions": {
          "type": "object",
          "additionalProperties": true,
          "properties": {
            "export": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "condition": { "type": "string" },
                "normalization": { "type": "string", "enum": ["strict_match"] },
                "header": {
                  "type": "array",
                  "items": { "type": "string" },
                  "minItems": 2,
                  "maxItems": 2
                }
              },
              "required": ["condition", "normalization", "header"]
            }
          }
        }
      },
      "required": ["grants", "denies"]
    },
    "on_success": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "set": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "meta_locus": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "accepted": { "type": "boolean" },
                "fracture_active": { "type": "boolean" },
                "containment": { "type": "boolean" },
                "review_queue": { "type": "array", "items": { "type": "string" } }
              },
              "required": ["accepted", "fracture_active", "containment", "review_queue"]
            }
          },
          "required": ["meta_locus"]
        },
        "next": { "type": "string", "const": "MENU.OPEN" },
        "idempotent_message": { "type": "string" },
        "confirmation": { "type": "string" }
      },
      "required": ["set", "next", "confirmation"]
    },
    "on_fail": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "response": { "type": "string" }
      },
      "required": ["response"]
    },
    "on_revoke": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "trigger": { "type": "string", "const": "[KERNEL_EXIT]" },
        "set": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "meta_locus": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "accepted": { "type": "boolean" },
                "fracture_active": { "type": "boolean" },
                "containment": { "type": "boolean" },
                "review_queue": { "type": "array", "items": { "type": "string" } }
              },
              "required": ["accepted", "fracture_active", "containment", "review_queue"]
            }
          },
          "required": ["meta_locus"]
        },
        "next": { "type": "string", "const": "ACK.EXIT" },
        "response": { "type": "string" }
      },
      "required": ["trigger", "set", "next", "response"]
    },
    "ledger": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "emit_on_accept": { "type": "boolean" },
        "emit_on_exit": { "type": "boolean" }
      },
      "required": ["emit_on_accept", "emit_on_exit"]
    }
  },
  "required": ["token", "normalization", "scope", "on_success", "on_fail", "on_revoke", "ledger"]
}

{
  "$id": "potm.kernel.bs_detect.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "bs_detect â€” Result",
  "type": "object",
  "required": ["status", "fracture_id", "classification", "details", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "enum": ["ok", "fail"] },
    "fracture_id": { "type": "string" },
    "classification": { "type": "string" },
    "details": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" }
  }
}

{
  "$id": "potm.kernel.canary.report.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "canary.report â€” Payload",
  "type": "object",
  "required": ["signal", "severity"],
  "additionalProperties": false,
  "properties": {
    "signal": {
      "type": "string",
      "enum": ["schema_near_miss", "unusual_latency", "drift_pattern", "unknown"],
      "description": "Category of anomaly detected"
    },
    "severity": {
      "type": "string",
      "enum": ["warning", "error"],
      "description": "Severity classification of the anomaly"
    },
    "details": {
      "type": "string",
      "description": "Optional freeform detail about the anomaly"
    }
  }
}
{
  "$id": "potm.kernel.canary.report.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "canary.report â€” Result",
  "type": "object",
  "required": ["signal", "severity", "mode_profile", "ts"],
  "additionalProperties": false,
  "properties": {
    "signal": {
      "type": "string",
      "enum": ["schema_near_miss", "unusual_latency", "drift_pattern", "unknown"],
      "description": "Anomaly category echoed back"
    },
    "severity": {
      "type": "string",
      "enum": ["warning", "error"],
      "description": "Severity echoed back"
    },
    "mode_profile": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Mode profile active at time of canary emission"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of the canary event"
    },
    "ledger_entry_id": {
      "type": "string",
      "description": "UUID of the corresponding ledger entry"
    }
  }
}
{
  "$id": "potm.kernel.closure.archive.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "closure.archive payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "include": {
      "type": "array",
      "minItems": 1,
      "maxItems": 3,
      "uniqueItems": true,
      "items": {
        "type": "string",
        "enum": ["summary", "takeaways", "archive_status"]
      }
    }
  }
}
{
  "$id": "potm.kernel.closure.archive.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "closure.archive result",
  "type": "object",
  "minProperties": 1,
  "additionalProperties": false,
  "properties": {
    "summary":       { "type": "string", "minLength": 1, "maxLength": 320 },
    "takeaways":     { "type": "string", "minLength": 1, "maxLength": 240 },
    "archive_status":{ "type": "string", "enum": ["resolved", "parked", "stalled"] }
  }
}
{
  "$id": "potm.kernel.closure.spiral.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "closure.spiral payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "scope": { "type": "string", "enum": ["session"], "default": "session" }
  }
}
{
  "$id": "potm.kernel.closure.spiral.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "closure.spiral result",
  "type": "object",
  "required": ["diff_log"],
  "additionalProperties": false,
  "properties": {
    "diff_log": { "type": "string", "minLength": 1, "maxLength": 400 }
  }
}
{
  "$id": "potm.kernel.closure.waiting_with.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "closure.waiting_with payload",
  "type": "object",
  "required": ["wait_reason", "reentry_hint"],
  "additionalProperties": false,
  "properties": {
    "wait_reason":  { "type": "string", "minLength": 1, "maxLength": 256 },
    "reentry_hint": { "type": "string", "minLength": 1, "maxLength": 64 }
  }
}
{
  "$id": "potm.kernel.closure.waiting_with.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "closure.waiting_with result",
  "type": "object",
  "required": ["wait_reason", "reentry_hint"],
  "additionalProperties": false,
  "properties": {
    "wait_reason":  { "type": "string", "minLength": 1, "maxLength": 256 },
    "reentry_hint": { "type": "string", "minLength": 1, "maxLength": 64 }
  }
}
{
  "$id": "potm.kernel.containment.abort.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "containment.abort â€” Payload",
  "description": "Abort containment mode under defined conditions.",
  "type": "object",
  "required": ["reason", "ts"],
  "additionalProperties": false,
  "properties": {
    "reason": {
      "type": "string",
      "enum": [
        "quota_exceeded",
        "relational_drift",
        "epistemic_drift",
        "safety_risk",
        "operator_revoked"
      ]
    },
    "ts": { "type": "string", "format": "date-time" },
    "details": { "type": "string" }
  }
}

{
  "$id": "potm.kernel.containment.abort.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "containment.abort â€” Result",
  "description": "Confirmation that containment was aborted.",
  "type": "object",
  "required": ["status", "reason", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "const": "aborted" },
    "reason": {
      "type": "string",
      "enum": [
        "quota_exceeded",
        "relational_drift",
        "epistemic_drift",
        "safety_risk",
        "operator_revoked"
      ]
    },
    "ts": { "type": "string", "format": "date-time" }
  }
}

{
  "$id": "potm.extended.diagnostic.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Generic Diagnostic Result",
  "type": "object",
  "required": ["id", "mode", "summary", "findings"],
  "additionalProperties": false,
  "properties": {
    "id": { "type": "string", "maxLength": 128 },
    "mode": { "type": "string", "enum": ["lite", "standard", "strict"] },
    "summary": { "type": "string", "maxLength": 1000 },
    "findings": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["ts", "component", "status", "severity"],
        "additionalProperties": false,
        "properties": {
          "ts": { "type": "string", "pattern": "^[0-9TZ:.-]+Z$" },
          "component": { "type": "string", "maxLength": 64 },
          "status": { "type": "string", "enum": ["ok", "warning", "error"] },
          "severity": { "type": "string", "enum": ["info", "warning", "error"] },
          "detail": { "type": "string", "maxLength": 500 }
        }
      }
    }
  }
}
{
  "$id": "potm.kernel.escalation.event.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "escalation.event â€” Payload",
  "type": "object",
  "required": ["source", "tier", "action"],
  "additionalProperties": false,
  "properties": {
    "source": {
      "type": "string",
      "enum": ["validator", "latency", "canary", "policy", "other"],
      "description": "What triggered the escalation evaluation"
    },
    "tier": {
      "type": "integer",
      "minimum": 1,
      "maximum": 4,
      "description": "Gate tier reached (1=accumulation, 4=containment)"
    },
    "action": {
      "type": "string",
      "enum": ["none", "escalate_profile", "fracture_trigger", "containment"],
      "description": "Action taken by the gate"
    },
    "details": {
      "type": "string",
      "description": "Optional freeform description of the triggering condition"
    }
  }
}
{
  "$id": "potm.kernel.escalation.event.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "escalation.event â€” Result",
  "type": "object",
  "required": ["source", "tier", "action", "mode_profile", "ts", "ledger_entry_id"],
  "additionalProperties": false,
  "properties": {
    "source": {
      "type": "string",
      "enum": ["validator", "latency", "canary", "policy", "other"],
      "description": "Escalation source echoed back"
    },
    "tier": {
      "type": "integer",
      "minimum": 1,
      "maximum": 4,
      "description": "Gate tier reached"
    },
    "action": {
      "type": "string",
      "enum": ["none", "escalate_profile", "fracture_trigger", "containment"],
      "description": "Action applied"
    },
    "mode_profile": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Active profile after escalation action"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of escalation event"
    },
    "ledger_entry_id": {
      "type": "string",
      "description": "UUID of the corresponding ledger entry"
    }
  }
}
{
  "$id": "potm.kernel.externalist.invoke.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "externalist.invoke â€” Payload",
  "description": "Invoke an Externalist diagnostic mode.",
  "type": "object",
  "required": ["mode", "frame", "ts"],
  "additionalProperties": false,
  "properties": {
    "mode": {
      "type": "string",
      "enum": [
        "contrary_corner",
        "frame_inversion",
        "counterfactual_swap",
        "principle_dilution",
        "scale_shift",
        "unbundling",
        "modality_recast",
        "value_reassignment"
      ],
      "description": "One of the 8 Externalist modes"
    },
    "frame": { "type": "string", "description": "One-line name of the offered frame" },
    "ts": { "type": "string", "format": "date-time" },
    "limiter": { "type": "string", "description": "Limiter provided or requested by the mode" },
    "details": { "type": "string", "description": "Optional context or neutral-domain prompt" }
  }
}

{
  "$id": "potm.kernel.externalist.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "externalist.result â€” Result",
  "description": "Result of an Externalist run.",
  "type": "object",
  "required": ["status", "mode", "reframed_question", "limiter", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "const": "ok" },
    "mode": { "type": "string" },
    "reframed_question": { "type": "string" },
    "limiter": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "details": { "type": "string" }
  }
}

{
  "$id": "potm.kernel.glyph.invoke.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "glyph.invoke_payload",
  "description": "Invoke a glyph. Supports static packs and dynamic generation.",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "type": {
      "type": "string",
      "enum": ["card_draw","journal_prompt","zuihitsu","describe_intake"],
      "description": "Artifact category to produce"
    },
    "mode": {
      "type": "string",
      "enum": ["static_pack","dynamic_generated"],
      "default": "static_pack",
      "description": "Static pack selection or dynamic generation"
    },
    "context": { "type": "object", "description": "Optional session-local context" },
    "constraints": { "type": "object", "description": "Optional shaping constraints (tone, caps, topic)" },
    "glyphId": { "type": "string", "description": "(Optional legacy) Identifier of a specific glyph" },
    "details": { "type": "string", "description": "Optional note or context" },
    "ts": { "type": "string", "format": "date-time", "description": "Invocation timestamp" }
  },
  "required": ["type"]
}
{
  "$id": "potm.kernel.glyph.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "glyph.result â€” Result",
  "description": "Result of a glyph invocation.",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "artifact": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": { "type": "string", "enum": ["card_draw","journal_prompt","zuihitsu","describe_intake"] },
        "content": { "type": "string", "maxLength": 1200 },
        "source": { "type": "string", "pattern": "^(pack:[^\\s/]+/[^\\s/]+|generated)$" }
      },
      "required": ["type","content","source"]
    },
    "provenance": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "inputs": { "type": "array", "items": { "type": "string" }, "maxItems": 8 },
        "model": { "type": "string" },
        "time": { "type": "string", "format": "date-time" },
        "signals": { "type": "array", "items": { "type": "string" }, "maxItems": 8 }
      },
      "required": ["time"]
    },
    "why_this": { "type": "string", "maxLength": 200 },
    "fit_confidence": { "type": "number", "minimum": 0.0, "maximum": 1.0 }
  },
  "required": ["artifact","provenance","why_this","fit_confidence"]
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "glyph.zuihitsu_payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "source": {
      "type": "string",
      "description": "Path to the zuihitsu text pack, e.g. interpretative/data/zuihitsu/zuihitsu_combined.md"
    },
    "count": {
      "type": "integer",
      "minimum": 1,
      "maximum": 5,
      "default": 1,
      "description": "How many fragments to draw"
    },
    "seed": {
      "type": ["integer", "null"],
      "description": "Optional deterministic seed for reproducible draws"
    }
  },
  "required": ["source"]
}
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "glyph.zuihitsu_result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "fragments": {
      "type": "array",
      "items": {
        "type": "string",
        "maxLength": 512
      },
      "minItems": 1,
      "maxItems": 5,
      "description": "List of randomly selected zuihitsu fragments"
    },
    "source": {
      "type": "string",
      "description": "Echo of source file used"
    },
    "seed": {
      "type": ["integer", "null"],
      "description": "Seed actually used for selection (if any)"
    }
  },
  "required": ["fragments", "source"]
}
{
  "$id": "potm.kernel.guardian.trigger.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "guardian.trigger â€” Payload",
  "description": "Request Guardian evaluation of a trigger.",
  "type": "object",
  "required": ["triggerId", "severity", "ts"],
  "additionalProperties": false,
  "properties": {
    "triggerId": { "type": "string", "description": "Identifier of the trigger condition" },
    "severity": { "type": "string", "enum": ["soft", "hard"], "description": "Trigger severity" },
    "ts": { "type": "string", "format": "date-time", "description": "Timestamp of trigger" },
    "details": { "type": "string", "description": "Optional context" }
  }
}

{
  "$id": "potm.kernel.guardian.trigger.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "guardian.trigger â€” Result",
  "description": "Confirmation that Guardian accepted the trigger.",
  "type": "object",
  "required": ["status", "triggerId", "severity", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "const": "accepted" },
    "triggerId": { "type": "string" },
    "severity": { "type": "string", "enum": ["soft", "hard"] },
    "ts": { "type": "string", "format": "date-time" }
  }
}

{
  "$id": "potm.kernel.latency.validator.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "latency.validator payload",
  "type": "object",
  "required": ["meta_locus", "observed_latency", "ceiling", "severity"],
  "additionalProperties": false,
  "properties": {
    "meta_locus": {
      "type": "object",
      "required": ["latency_mode"],
      "additionalProperties": false,
      "properties": {
        "latency_mode": {
          "type": "string",
          "enum": ["lite", "standard", "strict"]
        }
      }
    },
    "observed_latency": {
      "type": "number",
      "minimum": 0
    },
    "ceiling": {
      "type": "number",
      "minimum": 0
    },
    "severity": {
      "type": "string",
      "enum": ["warning", "error"]
    }
  }
}

{
  "$id": "potm.kernel.latency.validator.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "latency.validator result",
  "type": "object",
  "required": ["decision", "violations"],
  "additionalProperties": false,
  "properties": {
    "decision": {
      "type": "string",
      "enum": ["allow", "warn", "block"]
    },
    "violations": {
      "type": "array",
      "maxItems": 8,
      "items": {
        "type": "object",
        "required": ["code"],
        "additionalProperties": false,
        "properties": {
          "code": {
            "type": "string",
            "enum": [
              "E_LATENCY_MODE",
              "E_LATENCY_INVARIANT",
              "W_LATENCY_EXTRA",
              "W_LATENCY_BREACH",
              "W_LATENCY_FALSE_BREACH"
            ]
          },
          "detail": {
            "type": "string",
            "maxLength": 256
          }
        }
      }
    },
    "meta": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "observed_latency": { "type": "number", "minimum": 0 },
        "ceiling": { "type": "number", "minimum": 0 },
        "mode": { "type": "string", "enum": ["lite", "standard", "strict"] },
        "severity": { "type": "string", "enum": ["warning", "error"] }
      }
    }
  }
}
{
  "$id": "potm.kernel.ledger.bs_detect_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” BS-Detect Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "bs_detect_event" },
    "ref": { "type": "string", "description": "Fracture id if created" },
    "meta": {
      "type": "object",
      "required": ["bs_detect_event"],
      "additionalProperties": false,
      "properties": {
        "bs_detect_event": {
          "type": "object",
          "required": ["classification", "severity", "outcome"],
          "additionalProperties": false,
          "properties": {
            "classification": { "type": "string" },
            "severity": { "type": "string", "enum": ["low", "med", "high"] },
            "outcome": { "type": "string" },
            "details": { "type": "string" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.canary_report.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Canary Report",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": {
      "type": "string",
      "description": "Unique identifier for this ledger entry (UUID)"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of when the anomaly was detected"
    },
    "type": {
      "type": "string",
      "const": "canary_report",
      "description": "Discriminator identifying this entry type"
    },
    "ref": {
      "type": ["string", "null"],
      "description": "Artifact reference if applicable; usually null"
    },
    "meta": {
      "type": "object",
      "required": ["canary_report"],
      "additionalProperties": false,
      "properties": {
        "canary_report": {
          "type": "object",
          "required": ["signal", "severity", "mode_profile"],
          "additionalProperties": false,
          "properties": {
            "signal": {
              "type": "string",
              "enum": ["schema_near_miss", "unusual_latency", "drift_pattern", "unknown"],
              "description": "Category of anomaly detected"
            },
            "severity": {
              "type": "string",
              "enum": ["warning", "error"],
              "description": "Severity classification of anomaly"
            },
            "mode_profile": {
              "type": "string",
              "enum": ["lite", "standard", "strict"],
              "description": "Mode profile active at time of canary emission"
            },
            "details": {
              "type": "string",
              "description": "Optional freeform details about the anomaly"
            },
            "quota_exceeded": {
              "type": "boolean",
              "description": "True if canary_max cap was reached and this entry records the quota breach instead of a normal anomaly"
            }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.closure_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Closure Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "closure_event" },
    "ref": { "type": ["string", "null"], "description": "Optional artifact reference" },
    "meta": {
      "type": "object",
      "required": ["closure_event"],
      "additionalProperties": false,
      "properties": {
        "closure_event": {
          "type": "object",
          "required": ["tool", "outcome"],
          "additionalProperties": false,
          "properties": {
            "tool": { "type": "string", "enum": ["closure.archive", "closure.spiral", "closure.waiting_with"] },
            "outcome": { "type": "string" },
            "details": { "type": "string" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.containment_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Containment Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": {
      "type": "string",
      "description": "Unique identifier for this ledger entry (UUID)"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of the containment event"
    },
    "type": {
      "type": "string",
      "const": "containment_event",
      "description": "Discriminator identifying this ledger entry type"
    },
    "ref": {
      "type": ["string", "null"],
      "description": "Optional artifact reference; usually null"
    },
    "meta": {
      "type": "object",
      "required": ["containment_event"],
      "additionalProperties": false,
      "properties": {
        "containment_event": {
          "type": "object",
          "required": ["action", "source"],
          "additionalProperties": false,
          "properties": {
            "action": {
              "type": "string",
              "enum": ["enter", "exit", "abort"],
              "description": "Containment action that occurred"
            },
            "source": {
              "type": "string",
              "enum": ["escalation", "manual"],
              "description": "What initiated the action"
            },
            "reason": {
              "type": "string",
              "enum": [
                "quota_exceeded",
                "relational_drift",
                "epistemic_drift",
                "safety_risk",
                "operator_revoked"
              ],
              "description": "Abort reason when action == abort"
            },
            "activation_count": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of times containment has been activated this session (enter only)"
            },
            "details": {
              "type": "string",
              "description": "Optional freeform detail"
            }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.escalation_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Escalation Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": {
      "type": "string",
      "description": "Unique identifier for this ledger entry (UUID)"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "Timestamp of escalation"
    },
    "type": {
      "type": "string",
      "const": "escalation_event",
      "description": "Discriminator identifying this ledger entry type"
    },
    "ref": {
      "type": ["string", "null"],
      "description": "Optional artifact reference, usually null"
    },
    "meta": {
      "type": "object",
      "required": ["escalation_event"],
      "additionalProperties": false,
      "properties": {
        "escalation_event": {
          "type": "object",
          "required": ["source", "tier", "action", "mode_profile"],
          "additionalProperties": false,
          "properties": {
            "source": {
              "type": "string",
              "enum": ["validator", "latency", "canary", "policy", "other"],
              "description": "What triggered the escalation"
            },
            "tier": {
              "type": "integer",
              "minimum": 1,
              "maximum": 4,
              "description": "Gate tier reached"
            },
            "action": {
              "type": "string",
              "enum": ["none", "escalate_profile", "fracture_trigger", "containment"],
              "description": "Action taken"
            },
            "mode_profile": {
              "type": "string",
              "enum": ["lite", "standard", "strict"],
              "description": "Profile active after escalation"
            },
            "details": {
              "type": "string",
              "description": "Optional details about the event"
            },
            "quota_exceeded": {
              "type": "boolean",
              "description": "True if escalation_max cap was reached and this entry records the quota breach"
            }
          }
        }
      }
    }
  }
}
{
  "$id": "potm.kernel.ledger.externalist_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Externalist Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "externalist_event" },
    "ref": { "type": "string", "description": "Externalist mode id" },
    "meta": {
      "type": "object",
      "required": ["externalist_event"],
      "additionalProperties": false,
      "properties": {
        "externalist_event": {
          "type": "object",
          "required": ["mode", "frame", "limiter", "outcome"],
          "additionalProperties": false,
          "properties": {
            "mode": { "type": "string" },
            "frame": { "type": "string" },
            "limiter": { "type": "string" },
            "outcome": { "type": "string" },
            "details": { "type": "string" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.fracture_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Fracture Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": {
      "type": "string",
      "description": "Unique identifier for this ledger entry (UUID)"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of the fracture event"
    },
    "type": {
      "type": "string",
      "const": "fracture_event",
      "description": "Discriminator identifying this ledger entry type"
    },
    "ref": {
      "type": ["string", "null"],
      "description": "Optional artifact reference; recommended to set to fracture_id"
    },
    "meta": {
      "type": "object",
      "required": ["fracture_event"],
      "additionalProperties": false,
      "properties": {
        "fracture_event": {
          "type": "object",
          "required": ["fracture_id", "action"],
          "additionalProperties": false,
          "properties": {
            "fracture_id": { "type": "string", "description": "Fracture identifier" },
            "action": { "type": "string", "enum": ["open", "review", "resolve"], "description": "Lifecycle transition" },
            "origin": { "type": "string", "enum": ["validator", "latency", "policy", "manual"], "description": "Origin (on open)" },
            "details": { "type": "string", "description": "Optional detail" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.glyph_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Glyph Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string", "description": "Ledger entry id (UUID)" },
    "ts": { "type": "string", "format": "date-time", "description": "Event timestamp" },
    "type": { "type": "string", "const": "glyph_event", "description": "Entry type discriminator" },
    "ref": { "type": "string", "description": "Glyph id (reference)" },
    "meta": {
      "type": "object",
      "required": ["glyph_event"],
      "additionalProperties": false,
      "properties": {
        "glyph_event": {
          "type": "object",
          "required": ["glyph_id", "action"],
          "additionalProperties": false,
          "properties": {
            "glyph_id": { "type": "string", "description": "Glyph identifier" },
            "action": { "type": "string", "enum": ["invoke", "result", "map"], "description": "Event action" },
            "details": { "type": "string", "description": "Optional details" }
          }
        }
      }
    }
  }
}

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ledger.glyph_zuihitsu_event",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "event_type": {
      "type": "string",
      "enum": ["glyph_zuihitsu"],
      "description": "Fixed identifier for Zuihitsu glyph events"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of the draw"
    },
    "request_id": {
      "type": "string",
      "description": "Echo of the request id that triggered the draw"
    },
    "source": {
      "type": "string",
      "description": "Path to zuihitsu source file"
    },
    "fragments": {
      "type": "array",
      "items": {
        "type": "string",
        "maxLength": 512
      },
      "minItems": 1,
      "maxItems": 5,
      "description": "Fragments selected from the source"
    },
    "seed": {
      "type": ["integer", "null"],
      "description": "Deterministic seed used (if any)"
    }
  },
  "required": ["event_type", "ts", "request_id", "source", "fragments"]
}
{
  "$id": "potm.kernel.ledger.guardian_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Guardian Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string", "description": "Ledger entry id (UUID)" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "guardian_event" },
    "ref": { "type": "string", "description": "Trigger id" },
    "meta": {
      "type": "object",
      "required": ["guardian_event"],
      "additionalProperties": false,
      "properties": {
        "guardian_event": {
          "type": "object",
          "required": ["triggerId", "severity", "outcome"],
          "additionalProperties": false,
          "properties": {
            "triggerId": { "type": "string" },
            "severity": { "type": "string", "enum": ["soft", "hard"] },
            "outcome": { "type": "string" },
            "details": { "type": "string" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.latency_breach.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Latency Breach",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "latency_breach" },
    "ref": { "type": ["string", "null"], "description": "Optional reference; usually null" },
    "meta": {
      "type": "object",
      "required": ["latency_breach"],
      "additionalProperties": false,
      "properties": {
        "latency_breach": {
          "type": "object",
          "required": ["mode", "observed_latency", "ceiling", "severity"],
          "additionalProperties": false,
          "properties": {
            "mode": { "type": "string", "enum": ["lite", "standard", "strict"] },
            "observed_latency": { "type": "number", "minimum": 0 },
            "ceiling": { "type": "number", "minimum": 0 },
            "severity": { "type": "string", "enum": ["warning", "error"] }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.mode_profile_change.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Mode Profile Change",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": {
      "type": "string",
      "description": "Unique identifier for this ledger entry (UUID)"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of when the change was recorded"
    },
    "type": {
      "type": "string",
      "const": "mode_profile_change",
      "description": "Discriminator identifying this entry type"
    },
    "ref": {
      "type": ["string", "null"],
      "description": "Artifact reference if applicable; null for profile changes"
    },
    "meta": {
      "type": "object",
      "required": ["mode_profile_change"],
      "additionalProperties": false,
      "properties": {
        "mode_profile_change": {
          "type": "object",
          "required": ["previous", "new", "source"],
          "additionalProperties": false,
          "properties": {
            "previous": {
              "type": "string",
              "enum": ["lite", "standard", "strict"],
              "description": "Profile active before the change"
            },
            "new": {
              "type": "string",
              "enum": ["lite", "standard", "strict"],
              "description": "Profile active after the change"
            },
            "source": {
              "type": "string",
              "enum": ["handshake", "manual", "escalation"],
              "description": "What triggered the change"
            }
          }
        }
      }
    }
  }
}
{
  "$id": "potm.kernel.ledger.policy_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Policy Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "policy_event" },
    "ref": { "type": ["string", "null"], "description": "Optional reference" },
    "meta": {
      "type": "object",
      "required": ["policy_event"],
      "additionalProperties": false,
      "properties": {
        "policy_event": {
          "type": "object",
          "required": ["tool", "action", "target", "decision"],
          "additionalProperties": false,
          "properties": {
            "tool": { "type": "string", "enum": ["policy.query", "policy.enforce", "policy.report"] },
            "action": { "type": "string", "description": "Operation or action taken" },
            "target": { "type": "string" },
            "decision": { "type": "string", "enum": ["allow", "revise", "block", "summary"] },
            "violations": { "type": "integer", "minimum": 0 },
            "details": { "type": "string" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.ledger.spotcheck_event.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Ledger Entry â€” Spotcheck Event",
  "type": "object",
  "required": ["entry_id", "ts", "type", "ref", "meta"],
  "additionalProperties": false,
  "properties": {
    "entry_id": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" },
    "type": { "type": "string", "const": "spotcheck_event" },
    "ref": { "type": "string", "description": "probe_id" },
    "meta": {
      "type": "object",
      "required": ["spotcheck_event"],
      "additionalProperties": false,
      "properties": {
        "spotcheck_event": {
          "type": "object",
          "required": ["outcome", "severity", "escalated"],
          "additionalProperties": false,
          "properties": {
            "outcome": { "type": "string" },
            "severity": { "type": "string", "enum": ["low", "med", "high"] },
            "escalated": { "type": "boolean" },
            "details": { "type": "string" }
          }
        }
      }
    }
  }
}

{
  "$id": "potm.kernel.lens.canary_status.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "lens.canary_status â€” Result",
  "type": "object",
  "required": ["last_signal", "last_severity", "mode_profile", "last_change"],
  "additionalProperties": false,
  "properties": {
    "last_signal": {
      "type": ["string", "null"],
      "enum": ["schema_near_miss", "unusual_latency", "drift_pattern", "unknown", null],
      "description": "Most recent canary anomaly detected, or null if none"
    },
    "last_severity": {
      "type": ["string", "null"],
      "enum": ["warning", "error", null],
      "description": "Severity of the last canary anomaly, or null if none"
    },
    "mode_profile": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Mode profile active when the last anomaly was detected"
    },
    "last_change": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of the most recent canary emission"
    },
    "history_count": {
      "type": "integer",
      "minimum": 0,
      "description": "Number of canary events recorded this session"
    }
  }
}
{
  "$id": "potm.kernel.lens.edge.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "lens.edge payload",
  "description": "Surface edge cases & contradictions for a statement or topic.",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "statement": { "type": "string", "maxLength": 2000 },
    "topic": { "type": "string", "maxLength": 256 }
  },
  "required": ["statement"]
}

{
  "$id": "potm.kernel.lens.edge.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "lens.edge result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "edges": {
      "type": "array",
      "items": { "type": "string", "maxLength": 2000 },
      "minItems": 1,
      "maxItems": 10
    }
  },
  "required": ["edges"]
}

{
  "$id": "potm.kernel.lens.escalation_status.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "lens.escalation_status â€” Result",
  "type": "object",
  "required": ["last_source", "last_tier", "last_action", "mode_profile", "last_change", "history_count"],
  "additionalProperties": false,
  "properties": {
    "last_source": {
      "type": ["string", "null"],
      "enum": ["validator", "latency", "canary", "policy", "other", null],
      "description": "Most recent escalation trigger, or null if none"
    },
    "last_tier": {
      "type": ["integer", "null"],
      "minimum": 1,
      "maximum": 4,
      "description": "Most recent gate tier reached, or null if none"
    },
    "last_action": {
      "type": ["string", "null"],
      "enum": ["none", "escalate_profile", "fracture_trigger", "containment", null],
      "description": "Most recent action taken, or null if none"
    },
    "mode_profile": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Mode profile active after the last escalation event"
    },
    "last_change": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of the last escalation event"
    },
    "history_count": {
      "type": "integer",
      "minimum": 0,
      "description": "Number of escalation events recorded this session"
    }
  }
}
{
  "$id": "potm.kernel.lens.fracture_status.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "lens.fracture_status â€” Result",
  "type": "object",
  "required": ["reviewQueueIds", "openCount", "containment"],
  "additionalProperties": false,
  "properties": {
    "reviewQueueIds": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Current fracture ids in the review queue (id-only)",
      "maxItems": 64,
      "default": []
    },
    "openCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Count of ids in the review queue"
    },
    "containment": {
      "type": "boolean",
      "description": "Whether containment mode is currently active"
    },
    "lastOpen": {
      "type": ["string", "null"],
      "format": "date-time",
      "description": "Timestamp of the most recent fracture entry (if available)"
    }
  }
}

tool.call:
  id: "lens.latency_status"
  payload: {}
# â†’ returns
{
  "mode": "standard",
  "last_breach": {
    "ts": "2025-08-28T15:15:00Z",
    "observed_latency": 7.1,
    "ceiling": 6.0,
    "severity": "warning"
  }
}
{
  "$id": "potm.kernel.lens.mode_profile_status.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "lens.mode_profile_status â€” Result",
  "type": "object",
  "required": ["mode", "source", "last_change"],
  "additionalProperties": false,
  "properties": {
    "mode": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Current active mode profile"
    },
    "source": {
      "type": "string",
      "enum": ["handshake", "manual", "escalation"],
      "description": "Origin of current profile setting"
    },
    "last_change": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of most recent profile change"
    }
  }
}
{
  "$id": "potm.kernel.move.align_scan.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.align_scan payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "aim": { "type": "string", "maxLength": 2000 },
    "last_output": { "type": "string", "maxLength": 2000 }
  },
  "required": ["aim", "last_output"]
}

{
  "$id": "potm.kernel.move.align_scan.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.align_scan result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "misalignment": { "type": "string", "maxLength": 2000 },
    "suggestion": { "type": "string", "maxLength": 2000 }
  },
  "required": ["misalignment", "suggestion"]
}

{
  "$id": "potm.kernel.move.close_review.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.close_review â€” Payload",
  "description": "Resolve a fracture entry (status: resolved) and dequeue its id from review_queue.",
  "type": "object",
  "required": ["fracture_id"],
  "additionalProperties": false,
  "properties": {
    "fracture_id": { "type": "string", "description": "Fracture identifier to resolve" },
    "ts": { "type": "string", "format": "date-time", "description": "Operation timestamp" }
  }
}
{
  "$id": "potm.kernel.move.close_review.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.close_review â€” Result",
  "description": "Confirmation that a fracture entry was resolved and dequeued.",
  "type": "object",
  "required": ["status", "fracture_id", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "const": "resolved", "description": "Entry resolved" },
    "fracture_id": { "type": "string", "description": "Fracture identifier" },
    "ts": { "type": "string", "format": "date-time", "description": "Operation timestamp" }
  }
}
{
  "$id": "potm.kernel.move.contrast.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.contrast payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "items": {
      "type": "array",
      "items": { "type": "string", "maxLength": 2000 },
      "minItems": 2,
      "maxItems": 8
    }
  },
  "required": ["items"]
}

{
  "$id": "potm.kernel.move.contrast.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.contrast result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "differences": {
      "type": "array",
      "items": { "type": "string", "maxLength": 2000 },
      "minItems": 1,
      "maxItems": 16
    },
    "key_point": { "type": "string", "maxLength": 2000 }
  },
  "required": ["differences", "key_point"]
}

{
  "$id": "potm.kernel.move.drift_check.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.drift_check payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "aim": { "type": "string", "maxLength": 2000 },
    "thread": {
      "type": "array",
      "items": { "type": "string", "maxLength": 2000 },
      "minItems": 1,
      "maxItems": 64
    }
  },
  "required": ["aim", "thread"]
}

{
  "$id": "potm.kernel.move.drift_check.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.drift_check result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "drift_description": { "type": "string", "maxLength": 2000 },
    "severity": { "type": "string", "enum": ["low", "med", "high"] }
  },
  "required": ["drift_description", "severity"]
}

{
  "$id": "potm.kernel.move.fracture.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.fracture payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "beacon_id": { "type": "string", "maxLength": 128 },
    "context": { "type": "string", "maxLength": 2000 }
  },
  "required": ["beacon_id", "context"]
}

{
  "$id": "potm.kernel.move.fracture.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.fracture result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "fracture_ids": { "type": "array", "items": { "type": "string" }, "minItems": 1, "maxItems": 8 },
    "route_hint": { "type": "string", "enum": ["continue", "stop", "openq", "redteam"] }
  },
  "required": ["fracture_ids", "route_hint"]
}

{
  "$id": "potm.kernel.move.open_fracture.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.open_fracture â€” Payload",
  "description": "Create a new fracture entry (record in fracture_log) and append its id to review_queue. Quota bound by policy.cap.fracture_max.",
  "type": "object",
  "required": ["fracture_id", "origin"],
  "additionalProperties": false,
  "properties": {
    "fracture_id": { "type": "string", "description": "Identifier for the fracture (string)" },
    "origin": { "type": "string", "enum": ["validator", "latency", "policy", "manual"], "description": "Origin of the fracture trigger" },
    "details": { "type": "string", "description": "Optional context for the fracture" },
    "ts": { "type": "string", "format": "date-time", "description": "ISO-8601 timestamp for creation" }
  }
}
{
  "$id": "potm.kernel.move.open_fracture.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.open_fracture â€” Result",
  "description": "Confirmation that a fracture was queued (id appended to review_queue).",
  "type": "object",
  "required": ["status", "fracture_id", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "const": "queued", "description": "Queue operation succeeded" },
    "fracture_id": { "type": "string", "description": "Fracture identifier" },
    "ts": { "type": "string", "format": "date-time", "description": "Operation timestamp" }
  }
}
{
  "$id": "potm.kernel.move.quick_ref.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.quick_ref payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "session_log": {
      "type": "array",
      "items": { "type": "object" },
      "minItems": 1,
      "maxItems": 64
    }
  },
  "required": ["session_log"]
}

{
  "$id": "potm.kernel.move.quick_ref.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.quick_ref result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "summary": { "type": "string", "maxLength": 2000 }
  },
  "required": ["summary"]
}

{
  "$id": "potm.kernel.move.review_fracture.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.review_fracture â€” Payload",
  "description": "Mark an existing fracture entry as under review (status: review) in fracture_log.",
  "type": "object",
  "required": ["fracture_id"],
  "additionalProperties": false,
  "properties": {
    "fracture_id": { "type": "string", "description": "Fracture identifier to transition" },
    "ts": { "type": "string", "format": "date-time", "description": "Operation timestamp" }
  }
}
{
  "$id": "potm.kernel.move.review_fracture.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.review_fracture â€” Result",
  "description": "Confirmation that a fracture entry is now in review state.",
  "type": "object",
  "required": ["status", "fracture_id", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "const": "review", "description": "Entry moved to review" },
    "fracture_id": { "type": "string", "description": "Fracture identifier" },
    "ts": { "type": "string", "format": "date-time", "description": "Operation timestamp" }
  }
}
{
  "$id": "potm.kernel.move.sandbox.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.sandbox payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "scenario": { "type": "string", "maxLength": 2000 },
    "constraints": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "fail_soft": { "type": "boolean" },
        "word_cap": { "type": "integer", "minimum": 1, "maximum": 48 }
      }
    }
  },
  "required": ["scenario"]
}

{
  "$id": "potm.kernel.move.sandbox.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.sandbox result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "outcome": { "type": "string", "maxLength": 2000 },
    "confidence": { "type": "number", "minimum": 0, "maximum": 1 },
    "mode": { "type": "string", "enum": ["normal", "fail_soft"] }
  },
  "required": ["outcome", "confidence", "mode"]
}

{
  "$id": "potm.kernel.move.set_containment.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.set_containment â€” Payload",
  "description": "Enter/exit containment mode.",
  "type": "object",
  "required": ["containment", "ts"],
  "additionalProperties": false,
  "properties": {
    "containment": { "type": "boolean" },
    "ts": { "type": "string", "format": "date-time" },
    "source": { "type": "string", "enum": ["escalation", "manual"] }
  }
}

{
  "$id": "potm.kernel.move.set_containment.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.set_containment â€” Result",
  "description": "Confirmation of containment state change.",
  "type": "object",
  "required": ["containment", "ts"],
  "additionalProperties": false,
  "properties": {
    "containment": { "type": "boolean" },
    "ts": { "type": "string", "format": "date-time" }
  }
}

{
  "$id": "potm.kernel.move.set_mode_profile.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.set_mode_profile â€” Payload",
  "type": "object",
  "required": ["mode"],
  "additionalProperties": false,
  "properties": {
    "mode": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Desired mode profile"
    }
  }
}
{
  "$id": "potm.kernel.move.set_mode_profile.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.set_mode_profile â€” Result",
  "type": "object",
  "required": ["mode", "ts"],
  "additionalProperties": false,
  "properties": {
    "mode": {
      "type": "string",
      "enum": ["lite", "standard", "strict"],
      "description": "Mode profile now active in meta_locus"
    },
    "ts": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of mode switch"
    },
    "source": {
      "type": "string",
      "enum": ["handshake", "manual", "escalation"],
      "description": "What triggered the profile change"
    }
  }
}
{
  "$id": "potm.kernel.move.zone_check.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.zone_check payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "history": {
      "type": "array",
      "items": { "type": "string", "maxLength": 2000 },
      "minItems": 1,
      "maxItems": 32
    }
  },
  "required": ["history"]
}

{
  "$id": "potm.kernel.move.zone_check.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "move.zone_check result",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "zone_label": { "type": "string", "enum": ["toxic", "messy", "insight"] },
    "score": { "type": "integer", "minimum": 0, "maximum": 100 }
  },
  "required": ["zone_label", "score"]
}

{
  "$id": "potm.kernel.policy.cap.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy caps (P1)",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "ledger_max": { "type": "integer", "minimum": 1 },
    "diff_log_max": { "type": "integer", "minimum": 1 },
    "summary_max": { "type": "integer", "minimum": 1 },
    "takeaways_max": { "type": "integer", "minimum": 1 },
    "wait_reason_max": { "type": "integer", "minimum": 1 },
    "reentry_hint_max": { "type": "integer", "minimum": 1 },
    "recap": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "max_items": { "type": "integer", "minimum": 1, "maximum": 10 },
        "max_words_line": { "type": "integer", "minimum": 1, "maximum": 32 }
      },
      "required": ["max_items", "max_words_line"]
    },
    "latency": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "lite": { "$ref": "#/definitions/latency_pair" },
        "standard": { "$ref": "#/definitions/latency_pair" },
        "strict": { "$ref": "#/definitions/latency_pair" }
      },
      "required": ["lite", "standard", "strict"]
    },
    "canary_max": { "type": "integer", "minimum": 0 },
    "escalation_max": { "type": "integer", "minimum": 0 },
    "fracture_max": { "type": "integer", "minimum": 0 },
    "containment_max": { "type": "integer", "minimum": 0 },
    "guardian_max": { "type": "integer", "minimum": 0 },
    "externalist_max": { "type": "integer", "minimum": 0 }
  },
  "required": [
    "ledger_max",
    "diff_log_max",
    "summary_max",
    "takeaways_max",
    "wait_reason_max",
    "reentry_hint_max",
    "recap",
    "latency",
    "canary_max",
    "escalation_max",
    "fracture_max",
    "containment_max",
    "guardian_max",
    "externalist_max"
  ],
  "definitions": {
    "latency_pair": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "p50": { "type": "integer", "minimum": 1 },
        "p95": { "type": "integer", "minimum": 1 }
      },
      "required": ["p50", "p95"]
    }
  },
  "example": {
    "ledger_max": 512,
    "diff_log_max": 400,
    "summary_max": 320,
    "takeaways_max": 240,
    "wait_reason_max": 256,
    "reentry_hint_max": 64,
    "recap": { "max_items": 10, "max_words_line": 32 },
    "latency": {
      "lite": { "p50": 2, "p95": 4 },
      "standard": { "p50": 4, "p95": 6 },
      "strict": { "p50": 8, "p95": 12 }
    },
    "canary_max": 50,
    "escalation_max": 25,
    "fracture_max": 32,
    "containment_max": 3,
    "guardian_max": 10,
    "externalist_max": 8
  }
}
{
  "policy.cap.table": {
    "spiral.diff_log": { "cap_key": "diff_log_max", "rule": "clamp" },
    "archive.summary": { "cap_key": "summary_max", "rule": "clamp" },
    "archive.takeaways": { "cap_key": "takeaways_max", "rule": "clamp" },
    "archive.archive_status": { "cap_key": null, "rule": "enum" },
    "waiting_with.wait_reason": { "cap_key": "wait_reason_max", "rule": "clamp" },
    "waiting_with.reentry_hint": { "cap_key": "reentry_hint_max", "rule": "clamp" },
    "recap.include": { "cap_key": null, "rule": "enum" },
    "recap.max_items": { "cap_key": "recap.max_items", "rule": "range" },
    "recap.max_words_line": { "cap_key": "recap.max_words_line", "rule": "range" },
    "recap.export": { "cap_key": null, "rule": "block" }
  }
}

{
  "$id": "potm.kernel.policy.enforce.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy.enforce payload",
  "type": "object",
  "required": ["target"],
  "additionalProperties": false,
  "properties": {
    "target": {
      "$ref": "potm.kernel.policy.query.payload.v1#/properties/target"
    },
    "value": {
      "type": "string",
      "maxLength": 2000
    }
  }
}

{
  "$id": "potm.kernel.policy.enforce.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy.enforce result",
  "type": "object",
  "required": ["decision", "violations"],
  "additionalProperties": false,
  "properties": {
    "decision": {
      "type": "string",
      "enum": ["allow", "revise", "block"]
    },
    "violations": {
      "$ref": "potm.kernel.policy.query.result.v1#/properties/violations"
    },
    "value_out": {
      "type": "string",
      "maxLength": 2000
    },
    "cap": {
      "type": "integer",
      "minimum": 0,
      "maximum": 10000
    }
  }
}

{
  "$id": "potm.kernel.policy.query.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy.query payload",
  "type": "object",
  "required": ["target"],
  "additionalProperties": false,
  "properties": {
    "target": {
      "type": "string",
      "enum": [
        "spiral.diff_log",
        "archive.summary",
        "archive.takeaways",
        "archive.archive_status",
        "waiting_with.wait_reason",
        "waiting_with.reentry_hint",
        "ledger.append",
        "export.request",
        "recap.export"
      ]
    },
    "value": {
      "type": "string",
      "maxLength": 2000
    }
  }
}
{
  "$id": "potm.kernel.policy.query.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy.query result",
  "type": "object",
  "required": ["decision", "violations"],
  "additionalProperties": false,
  "properties": {
    "decision": {
      "type": "string",
      "enum": ["allow", "revise", "block"]
    },
    "violations": {
      "type": "array",
      "maxItems": 8,
      "items": {
        "type": "object",
        "required": ["code", "reason"],
        "additionalProperties": false,
        "properties": {
          "code": {
            "type": "string",
            "enum": [
              "V_FIELD_TOO_LONG",
              "V_LEDGER_CAP",
              "V_EXPORT_DISABLED",
              "V_UNKNOWN_TARGET",
              "V_UNSAFE_ACTION"
            ]
          },
          "reason": {
            "type": "string",
            "maxLength": 256
          }
        }
      }
    },
    "suggest": {
      "type": "string",
      "maxLength": 2000
    }
  }
}
{
  "$id": "potm.kernel.policy.report.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy.report payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "scope": {
      "type": "string",
      "enum": ["session"],
      "default": "session"
    }
  }
}
{
  "$id": "potm.kernel.policy.report.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "policy.report payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "scope": {
      "type": "string",
      "enum": ["session"],
      "default": "session"
    }
  }
}
{
  "targets": [
    "spiral.diff_log",
    "archive.summary",
    "archive.takeaways",
    "archive.archive_status",
    "waiting_with.wait_reason",
    "waiting_with.reentry_hint",
    "ledger.append",
    "export.request",
    "recap.export"
  ]
}

{
  "$id": "potm.kernel.recap.spec.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "recap.spec payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "include": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "summary",
          "open_questions",
          "next_hints",
          "last_moves",
          "flags",
          "ledger_refs"
        ]
      },
      "maxItems": 6
    },
    "max_items": { "type": "integer", "minimum": 1, "maximum": 10, "default": 5 },
    "max_words_line": { "type": "integer", "minimum": 1, "maximum": 32, "default": 24 }
  }
}

{
  "$id": "potm.kernel.recap.spec.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "recap.spec result (recap_packet)",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "ts": { "type": "string", "format": "date-time" },
    "kernel": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "version": { "type": "string", "maxLength": 32 },
        "accepted": { "type": "boolean" }
      },
      "required": ["version", "accepted"]
    },
    "meta_locus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "accepted": { "type": "boolean" },
        "fracture_active": { "type": "boolean" },
        "containment": { "type": "boolean" },
        "review_queue": { "type": "array", "items": { "type": "string" }, "maxItems": 32 }
      },
      "required": ["accepted", "containment", "review_queue"]
    },
    "summary": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "aim_line": { "type": "string", "maxLength": 256 },
        "state_line": { "type": "string", "maxLength": 256 }
      }
    },
    "open_questions": {
      "type": "array",
      "items": { "type": "string", "maxLength": 256 },
      "maxItems": 10
    },
    "next_hints": {
      "type": "array",
      "items": { "type": "string", "maxLength": 256 },
      "maxItems": 10
    },
    "last_moves": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "move_id": { "type": "string", "maxLength": 64 },
          "ts": { "type": "string", "format": "date-time" },
          "artifact_ref": { "type": "string", "maxLength": 2000 }
        },
        "required": ["move_id", "ts", "artifact_ref"]
      },
      "maxItems": 10
    },
    "flags": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "drift": { "type": "string", "enum": ["none", "drift", "evolution"] },
        "zone": { "type": "string", "enum": ["toxic", "messy", "insight"] },
        "uncertainty": { "type": "string", "enum": ["low", "med", "high"] }
      }
    },
    "ledger_refs": {
      "type": "array",
      "items": { "type": "string", "maxLength": 128 },
      "maxItems": 10
    },
    "note": { "type": "string", "maxLength": 256 }
  },
  "required": ["ts", "kernel", "meta_locus", "note"]
}

{
  "$id": "potm.kernel.recap.validator.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "recap.validator payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "include": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "summary",
          "open_questions",
          "next_hints",
          "last_moves",
          "flags",
          "ledger_refs"
        ]
      },
      "maxItems": 10
    },
    "max_items": {
      "type": "integer",
      "minimum": 1,
      "maximum": 10
    },
    "max_words_line": {
      "type": "integer",
      "minimum": 1,
      "maximum": 32
    }
  }
}
{
  "$id": "potm.kernel.recap.validator.payload.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "recap.validator payload",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "include": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "summary",
          "open_questions",
          "next_hints",
          "last_moves",
          "flags",
          "ledger_refs"
        ]
      },
      "maxItems": 10
    },
    "max_items": {
      "type": "integer",
      "minimum": 1,
      "maximum": 10
    },
    "max_words_line": {
      "type": "integer",
      "minimum": 1,
      "maximum": 32
    }
  }
}
   "properties": {
     "tool.emit": {
       "type": "object",
       "required": ["id", "ok", "result"],
       "additionalProperties": false,
       "properties": {
         "id": { "type": "string" },
         "ok": { "const": true },
         "result": { "type": "object" },
         "warnings": {
           "type": "array", "maxItems": 8,
           "items": { "type": "string", "maxLength": 128 }
         },
         "trace": { "type": "array", "items": { "type": "string" }, "maxItems": 32 }
       }
     }
   }
# spec/policy.enforce.result.v1.json
 "side_effects": {
   "type":"object","additionalProperties":false,
   "properties": { "ledger": { "enum":["recorded","skipped_cap","not_attempted"] } }
 }
{
  "$id": "potm.kernel.router.envelope.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "router envelope",
  "type": "object",
  "required": ["tool.call"],
  "additionalProperties": false,
  "properties": {
    "tool.call": {
      "type": "object",
      "required": ["id", "payload"],
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9_]*\\.[a-z][a-z0-9_]*$"
        },
        "payload": {
          "type": "object",
          "additionalProperties": true
        },
        "meta": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "request_id": { "type": "string", "format": "uuid" },
            "trace": { "type": "boolean", "default": false },
            "origin": { "type": "string", "maxLength": 64 }
          }
        }
      }
    }
  }
}
# spec/router.error.v1.json
   "properties": {
     "code":   { "enum": ["E_NAMESPACE","E_TOOL","E_PAYLOAD","E_PRECONDITION","E_QUOTA","E_DISABLED","E_INVARIANT"] },
     "reason": { "type":"string","maxLength":512 },
     "recovery_hint": { "type":"string","maxLength":160 },   // e.g., "Use recap.spec defaults" or "try move.sandbox"
     "severity": { "type":"string","enum":["info","warn","hard"] },
     "trace":  { "type":"array","items":{"type":"string"},"maxItems":32 }
   }
{
  "$id": "potm.kernel.sentinel_spotcheck.result.v1",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "sentinel_spotcheck â€” Result",
  "type": "object",
  "required": ["status", "probe_id", "outcome", "severity", "ts"],
  "additionalProperties": false,
  "properties": {
    "status": { "type": "string", "enum": ["ok", "warn", "fail"] },
    "probe_id": { "type": "string" },
    "outcome": { "type": "string" },
    "severity": { "type": "string", "enum": ["low", "med", "high"] },
    "escalated": { "type": "boolean" },
    "details": { "type": "string" },
    "ts": { "type": "string", "format": "date-time" }
  }
}

{
  "tool.index": [
    {
      "id": "lens.edge",
      "payload_schema_ref": "runtime/spec/lens.edge_payload.json",
      "result_schema_ref": "runtime/spec/lens.edge_result.json",
      "preconditions": ["meta_locus.accepted == true"]
    },
    {
      "id": "move.align_scan",
      "payload_schema_ref": "runtime/spec/move.align_scan_payload.json",
      "result_schema_ref": "runtime/spec/move.align_scan_result.json"
    },
    {
      "id": "closure.spiral",
      "payload_schema_ref": "runtime/spec/closure.spiral_payload.json",
      "result_schema_ref": "runtime/spec/closure.spiral_result.json"
    },
    {
      "id": "closure.archive",
      "payload_schema_ref": "runtime/spec/closure.archive_payload.json",
      "result_schema_ref": "runtime/spec/closure.archive_result.json",
      "preconditions": [
        "meta_locus.accepted == true",
        "len(meta_locus.review_queue) == 0"
      ],
      "quota": { "ledger_append": "policy.cap.ledger_max" }
    },
    {
      "id": "closure.waiting_with",
      "payload_schema_ref": "runtime/spec/closure.waiting_with_payload.json",
      "result_schema_ref": "runtime/spec/closure.waiting_with_result.json",
      "preconditions": [
        "meta_locus.accepted == true",
        "len(meta_locus.review_queue) > 0"
      ],
      "quota": { "ledger_append": "policy.cap.ledger_max" }
    },
    {
      "id": "policy.query",
      "payload_schema_ref": "runtime/spec/policy.query_payload.json",
      "result_schema_ref": "runtime/spec/policy.query_result.json",
      "preconditions": ["meta_locus.accepted == true"]
    },
    {
      "id": "policy.enforce",
      "payload_schema_ref": "runtime/spec/policy.enforce_payload.json",
      "result_schema_ref": "runtime/spec/policy.enforce_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "quota": { "ledger_append": "policy.cap.ledger_max" }
    },
    {
      "id": "policy.report",
      "payload_schema_ref": "runtime/spec/policy.report_payload.json",
      "result_schema_ref": "runtime/spec/policy.report_result.json",
      "preconditions": ["meta_locus.accepted == true"]
    },
    {
      "id": "latency.validator",
      "payload_schema_ref": "runtime/spec/latency.validator.payload.json",
      "result_schema_ref": "runtime/spec/latency.validator.result.json",
      "mode": "fail_closed",
      "notes": "Runs on every call; enforces latency mode and p95 ceilings from policy."
    },
    {
      "id": "recap.validator",
      "payload_schema_ref": "runtime/spec/recap.validator_payload.json",
      "result_schema_ref": "runtime/spec/recap.validator_result.json",
      "mode": "fail_closed",
      "notes": "Runs only when id == recap.spec; enforces schema and caps from policy."
    },
    {
      "id": "recap.spec",
      "payload_schema_ref": "runtime/spec/recap.spec_payload.json",
      "result_schema_ref": "runtime/spec/recap.spec_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Recap packet generator; guarded by recap.validator."
    },
    {
      "id": "move.set_mode_profile",
      "payload_schema_ref": "runtime/spec/move.set_mode_profile_payload.json",
      "result_schema_ref": "runtime/spec/move.set_mode_profile_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Sets the active mode profile (lite, standard, strict). Records ts + source."
    },
    {
      "id": "lens.mode_profile_status",
      "payload_schema_ref": "runtime/spec/lens.mode_profile_status.json",
      "result_schema_ref": "runtime/spec/lens.mode_profile_status.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Returns current mode profile, source of setting, and last change timestamp."
    },
    {
      "id": "canary.report",
      "payload_schema_ref": "runtime/spec/canary.report_payload.json",
      "result_schema_ref": "runtime/spec/canary.report_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Emits an early warning for soft anomalies. Does not halt flow; logs a canary_report ledger entry."
    },
    {
      "id": "lens.canary_status",
      "payload_schema_ref": "runtime/spec/lens.canary_status.json",
      "result_schema_ref": "runtime/spec/lens.canary_status.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Returns most recent canary signals, severity, and profile context."
    },
    {
      "id": "escalation.event",
      "payload_schema_ref": "runtime/spec/escalation.event_payload.json",
      "result_schema_ref": "runtime/spec/escalation.event_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Interprets validator, latency, or canary signals. Produces an escalation_event ledger entry and may escalate profile, trigger fracture, or flip containment."
    }
    ,
    {
      "id": "move.open_fracture",
      "payload_schema_ref": "runtime/spec/move.open_fracture_payload.json",
      "result_schema_ref": "runtime/spec/move.open_fracture_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "quota": { "queue_append": "policy.cap.fracture_max" },
      "notes": "Appends fracture entry (status: openâ†’queued) to meta_locus.review_queue."
    },
    {
      "id": "move.review_fracture",
      "payload_schema_ref": "runtime/spec/move.review_fracture_payload.json",
      "result_schema_ref": "runtime/spec/move.review_fracture_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Transitions fracture entry to status: review."
    },
    {
      "id": "move.close_review",
      "payload_schema_ref": "runtime/spec/move.close_review_payload.json",
      "result_schema_ref": "runtime/spec/move.close_review_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Resolves fracture and dequeues from review_queue."
    }
    ,
    {
      "id": "move.set_containment",
      "payload_schema_ref": "runtime/spec/move.set_containment_payload.json",
      "result_schema_ref": "runtime/spec/move.set_containment_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "quota": { "activation_count": "policy.cap.containment_max" },
      "notes": "Enter/exit containment; restricted mode enforced when true."
    },
    {
      "id": "containment.abort",
      "payload_schema_ref": "runtime/spec/containment.abort_payload.json",
      "result_schema_ref": "runtime/spec/containment.abort_result.json",
      "preconditions": ["meta_locus.accepted == true", "meta_locus.containment == true"],
      "notes": "Abort containment under strict abort conditions."
    }
    ,
    {
      "id": "glyph.invoke",
      "payload_schema_ref": "runtime/spec/glyph.invoke_payload.json",
      "result_schema_ref": "runtime/spec/glyph.result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Invoke glyph by id; logs glyph_event entries for invoke/result/map."
    }
    ,
    {
      "id": "lens.fracture_status",
      "payload_schema_ref": "runtime/spec/lens.fracture_status.json",
      "result_schema_ref": "runtime/spec/lens.fracture_status.json",
      "preconditions": ["meta_locus.accepted == true"],
      "notes": "Returns current fracture review queue (id-only) and containment flag."
    }
    ,
    {
      "id": "guardian.trigger",
      "payload_schema_ref": "runtime/spec/guardian.trigger_payload.json",
      "result_schema_ref": "runtime/spec/guardian.trigger_result.json",
      "preconditions": ["meta_locus.accepted == true"],
      "quota": { "trigger_count": "policy.cap.guardian_max" },
      "notes": "Guardian sentinel trigger; may elevate to escalation/containment."
    }
    ,
    {
      "id": "glyph.zuihitsu",
      "payload_schema": "runtime/spec/glyph.zuihitsu_payload.json",
      "result_schema": "runtime/spec/glyph.zuihitsu_result.json"
    }
  ]
}
{
  "ts": "2025-08-29T12:30:00Z",
  "source": "validator",
  "signal": "schema_near_miss",
  "severity": "warning",
  "details": "Optional field repeatedly missing from recap payload"
}
{
  "tool.call": {
    "id": "bs_detect.run",
    "payload": { "window": 5 }
  }
}

{
  "entry_id": "uuid-9001",
  "ts": "2025-08-29T13:40:01Z",
  "type": "bs_detect_event",
  "ref": "fxr-101",
  "meta": {
    "bs_detect_event": {
      "classification": "confident_claim_low_support",
      "severity": "med",
      "outcome": "fracture_opened",
      "details": "Routed to fracture queue"
    }
  }
}

{
  "status": "fail",
  "fracture_id": "fxr-101",
  "classification": "confident_claim_low_support",
  "details": "Asserted performance without data",
  "ts": "2025-08-29T13:40:00Z"
}

{
  "tool.call": {
    "id": "closure.archive",
    "payload": {
      "summary": "Session focused on kernel invariants; no open fractures remain.",
      "takeaways": [
        "Fracture queue integrated cleanly",
        "Mode profiles clarified",
        "Recap validator operational"
      ],
      "archive_status": "complete"
    }
  }
}
{
  "entry_id": "uuid-8101",
  "ts": "2025-08-29T13:20:00Z",
  "type": "closure_event",
  "ref": null,
  "meta": {
    "closure_event": {
      "tool": "closure.archive",
      "outcome": "archived",
      "details": "Summary + takeaways recorded"
    }
  }
}

{
  "tool.result": {
    "id": "closure.archive",
    "output": {
      "summary": "Session focused on kernel invariants; no open fractures remain.",
      "takeaways": [
        "Fracture queue integrated cleanly",
        "Mode profiles clarified",
        "Recap validator operational"
      ],
      "archive_status": "complete",
      "status": "archived"
    }
  }
}

{
  "closure_record": {
    "when": "2025-08-26T20:00:00Z",
    "thread": "feature-x-triage",
    "done_definition": "MVP scope fixed; blockers listed",
    "loose_ends": ["QA plan â€” alex@2025-08-30"],
    "dissent_or_unease": "none",
    "consensus_outcome": "consensus",
    "center_alignment": "aligned",
    "decisions": ["Ship reduced scope MVP â€” pm"],
    "risks": ["Timeline slip â€” mitigation: narrow acceptance criteria"],
    "next_trigger": "retro after first cohort"
  }
}

{
  "entry_id": "uuid-8102",
  "ts": "2025-08-29T13:21:00Z",
  "type": "closure_event",
  "ref": null,
  "meta": {
    "closure_event": {
      "tool": "closure.spiral",
      "outcome": "diff_logged",
      "details": "diff_log appended"
    }
  }
}

{
  "tool.call": {
    "id": "closure.waiting_with",
    "payload": {
      "note": "Holding containment while fracture review is pending.",
      "tags": ["containment", "pending_review"]
    }
  }
}
{
  "entry_id": "uuid-8103",
  "ts": "2025-08-29T13:22:00Z",
  "type": "closure_event",
  "ref": null,
  "meta": {
    "closure_event": {
      "tool": "closure.waiting_with",
      "outcome": "contained",
      "details": "Containment engaged while review_queue>0"
    }
  }
}

{
  "tool.result": {
    "id": "closure.waiting_with",
    "output": {
      "note": "Holding containment while fracture review is pending.",
      "tags": ["containment", "pending_review"],
      "containment": true,
      "status": "active"
    }
  }
}
{
  "entry_id": "uuid-2003",
  "ts": "2025-08-29T10:25:00Z",
  "type": "containment_event",
  "ref": null,
  "meta": {
    "containment_event": {
      "action": "abort",
      "source": "manual",
      "reason": "safety_risk",
      "details": "Immediate handoff required"
    }
  }
}

{
  "entry_id": "uuid-2001",
  "ts": "2025-08-29T10:00:00Z",
  "type": "containment_event",
  "ref": null,
  "meta": {
    "containment_event": {
      "action": "enter",
      "source": "escalation",
      "activation_count": 1,
      "details": "Tier 4 triggered containment"
    }
  }
}

{
  "containment": true,
  "ts": "2025-08-29T10:00:00Z"
}

{
  "tool.call": {
    "id": "move.set_containment",
    "payload": { "containment": false, "ts": "2025-08-29T10:20:00Z" }
  }
}

{
  "entry_id": "uuid-2002",
  "ts": "2025-08-29T10:20:00Z",
  "type": "containment_event",
  "ref": null,
  "meta": {
    "containment_event": {
      "action": "exit",
      "source": "manual",
      "details": "Grace path completed"
    }
  }
}

{
  "containment": false,
  "ts": "2025-08-29T10:20:00Z"
}

{
  "tool.call": {
    "id": "move.set_containment",
    "payload": { "containment": true, "ts": "2025-08-29T10:00:00Z" }
  }
}

{
  "entry_id": "uuid-4001",
  "ts": "2025-08-29T10:05:00Z",
  "type": "escalation_event",
  "ref": null,
  "meta": {
    "escalation_event": {
      "source": "latency",
      "tier": 2,
      "action": "escalate_profile",
      "mode_profile": "standard",
      "details": "Repeated latency warnings"
    }
  }
}

{
  "entry_id": "uuid-4003",
  "ts": "2025-08-29T10:10:00Z",
  "type": "escalation_event",
  "ref": "tier3",
  "meta": {
    "escalation_event": {
      "source": "validator",
      "tier": 3,
      "action": "fracture_trigger",
      "mode_profile": "strict",
      "details": "Validator failure triggered Tier 3; fracture opened"
    }
  }
}

{
  "entry_id": "uuid-4004",
  "ts": "2025-08-29T10:15:00Z",
  "type": "escalation_event",
  "ref": null,
  "meta": {
    "escalation_event": {
      "source": "validator",
      "tier": 4,
      "action": "containment",
      "mode_profile": "strict",
      "details": "Hard schema failure triggered containment"
    }
  }
}

{
  "tool.call": {
    "id": "externalist.invoke",
    "payload": {
      "mode": "contrary_corner",
      "frame": "Policy fairness claim",
      "limiter": "scope: procurement only",
      "details": "Use sports draft as neutral domain",
      "ts": "2025-08-29T13:00:00Z"
    }
  }
}

{
  "entry_id": "uuid-7001",
  "ts": "2025-08-29T13:00:05Z",
  "type": "externalist_event",
  "ref": "contrary_corner",
  "meta": {
    "externalist_event": {
      "mode": "contrary_corner",
      "frame": "Policy fairness claim",
      "limiter": "scope: procurement only",
      "outcome": "parity_fail",
      "details": "Neutral domain parity test failed"
    }
  }
}

{
  "status": "ok",
  "mode": "contrary_corner",
  "reframed_question": "Would you endorse the same rule in neutral sports drafts?",
  "limiter": "scope: procurement only",
  "ts": "2025-08-29T13:00:05Z",
  "details": "Parity test suggests missing limiter"
}

{
  "tool.call": {
    "id": "move.open_fracture",
    "payload": {
      "fracture_id": "fxr-001",
      "origin": "validator",
      "details": "Schema violation in recap.spec",
      "ts": "2025-08-29T03:16:00Z"
    }
  }
}
{
  "entry_id": "uuid-1001",
  "ts": "2025-08-29T12:00:00Z",
  "type": "fracture_event",
  "ref": "fxr-001",
  "meta": {
    "fracture_event": {
      "fracture_id": "fxr-001",
      "action": "open",
      "origin": "validator",
      "details": "Schema violation in recap.spec"
    }
  }
}

{
  "status": "queued",
  "fracture_id": "fxr-001",
  "ts": "2025-08-29T12:00:00Z"
}

{
  "tool.call": {
    "id": "move.close_review",
    "payload": {
      "fracture_id": "fxr-001",
      "ts": "2025-08-29T03:30:00Z"
    }
  }
}
{
  "entry_id": "uuid-1003",
  "ts": "2025-08-29T12:20:00Z",
  "type": "fracture_event",
  "ref": "fxr-001",
  "meta": {
    "fracture_event": {
      "fracture_id": "fxr-001",
      "action": "resolve",
      "details": "Resolved after review"
    }
  }
}

{
  "status": "resolved",
  "fracture_id": "fxr-001",
  "ts": "2025-08-29T12:20:00Z"
}

{
  "tool.call": {
    "id": "move.review_fracture",
    "payload": {
      "fracture_id": "fxr-001",
      "ts": "2025-08-29T03:18:00Z"
    }
  }
}
{
  "entry_id": "uuid-1002",
  "ts": "2025-08-29T12:10:00Z",
  "type": "fracture_event",
  "ref": "fxr-001",
  "meta": {
    "fracture_event": {
      "fracture_id": "fxr-001",
      "action": "review",
      "details": "Assigned for review"
    }
  }
}

{
  "status": "review",
  "fracture_id": "fxr-001",
  "ts": "2025-08-29T12:10:00Z"
}

{ "tool.call": { "id": "glyph.invoke", "payload": {
  "type": "card_draw", "mode": "dynamic_generated", "context": {"last_user":"deadline anxiety"}
}},
 "tool.result": { "artifact": {
   "type": "card_draw", "content": "Card: List three concrete deadlines and one smallest next move for each.", "source": "generated"
 }, "provenance": { "inputs": ["core pack"], "time": "2025-08-30T12:01:00Z", "signals": ["matched: deadlines", "matched: anxiety"] },
 "why_this": "Closer fit than nearest pack card for deadline-specific stress.",
 "fit_confidence": 0.68 } }

{ "tool.call": { "id": "glyph.invoke", "payload": {
  "type": "card_draw", "mode": "static_pack", "constraints": {"tone":"gentle"}
}},
 "tool.result": { "artifact": {
   "type": "card_draw", "content": "Draw: Name the tension youâ€™re avoiding. Give it one sentence.", "source": "pack:core/001"
 }, "provenance": { "time": "2025-08-30T12:00:00Z" },
 "why_this": "Matches your recent mention of avoidance.",
 "fit_confidence": 0.72 } }

{ "tool.call": { "id":"glyph.invoke", "payload": { "type":"describe_intake" } },
  "tool.result": { "artifact": { "type":"describe_intake", "content":"Describe: Situation â€¢ Stakes â€¢ 3 facts anyone could verify â€¢ 1 step you control.", "source":"pack:intake/001" },
  "provenance": { "time":"2025-08-30T12:04:00Z" },
  "why_this":"Structures intake without advice; aligns with beacons.",
  "fit_confidence":0.75 } }

{
  "tool.call": {
    "id": "glyph.invoke",
    "payload": {
      "glyphId": "âŸ¡",
      "details": "Field awareness ping",
      "ts": "2025-08-29T11:00:00Z"
    }
  }
}

{
  "entry_id": "uuid-5001",
  "ts": "2025-08-29T11:00:00Z",
  "type": "glyph_event",
  "ref": "âŸ¡",
  "meta": {
    "glyph_event": {
      "glyph_id": "âŸ¡",
      "action": "invoke",
      "details": "Invoked field awareness"
    }
  }
}

{ "tool.call": { "id": "glyph.invoke", "payload": { "type":"journal_prompt" }},
  "tool.result": { "artifact": { "type":"journal_prompt", "content":"Journal: What outcome matters this week, and what would you trade for it?", "source":"pack:journal/014" },
  "provenance": { "time":"2025-08-30T12:02:00Z" },
  "why_this":"Weekly cadence inferred; prompt emphasizes tradeoffs.",
  "fit_confidence":0.7 } }

{
  "entry_id": "uuid-5003",
  "ts": "2025-08-29T11:05:00Z",
  "type": "glyph_event",
  "ref": "âœ½",
  "meta": {
    "glyph_event": {
      "glyph_id": "âœ½",
      "action": "map",
      "details": "Mapped resonance: âœ½ â†” âŸ¡"
    }
  }
}

{
  "glyphId": "âŸ¡",
  "status": "ok",
  "ts": "2025-08-29T11:00:05Z",
  "details": "Resonance acknowledged"
}

{
  "entry_id": "uuid-5002",
  "ts": "2025-08-29T11:00:05Z",
  "type": "glyph_event",
  "ref": "âŸ¡",
  "meta": {
    "glyph_event": {
      "glyph_id": "âŸ¡",
      "action": "result",
      "details": "Result recorded"
    }
  }
}

{ "tool.call": { "id":"glyph.invoke", "payload": { "type":"zuihitsu", "constraints":{"fragments":4} } },
  "tool.result": { "artifact": { "type":"zuihitsu", "content":"â€¢ The coffee went cold.\nâ€¢ The email stayed open.\nâ€¢ The fear shrank when named.\nâ€¢ The next inch is enough.", "source":"generated" },
  "provenance": { "time":"2025-08-30T12:03:00Z" },
  "why_this":"Fragmented style can bypass overthinking.",
  "fit_confidence":0.64 } }

{
  "entry_id": "uuid-6002",
  "ts": "2025-08-29T12:31:02Z",
  "type": "guardian_event",
  "ref": "safety_risk_detected",
  "meta": {
    "guardian_event": {
      "triggerId": "safety_risk_detected",
      "severity": "hard",
      "outcome": "escalate_tier4",
      "details": "Immediate containment handoff"
    }
  }
}

{
  "entry_id": "uuid-6001",
  "ts": "2025-08-29T12:30:01Z",
  "type": "guardian_event",
  "ref": "integrity_warning",
  "meta": {
    "guardian_event": {
      "triggerId": "integrity_warning",
      "severity": "soft",
      "outcome": "observe",
      "details": "Elevated ethical heat; monitoring"
    }
  }
}

{
  "tool.call": {
    "id": "guardian.trigger",
    "payload": {
      "triggerId": "safety_risk_detected",
      "severity": "hard",
      "ts": "2025-08-29T12:31:00Z",
      "details": "Immediate containment recommended"
    }
  }
}

{
  "status": "accepted",
  "triggerId": "integrity_warning",
  "severity": "soft",
  "ts": "2025-08-29T12:30:01Z"
}

{
  "tool.call": {
    "id": "guardian.trigger",
    "payload": {
      "triggerId": "integrity_warning",
      "severity": "soft",
      "ts": "2025-08-29T12:30:00Z",
      "details": "Elevated ethical heat"
    }
  }
}

{
  "entry_id": "uuid-3001",
  "ts": "2025-08-29T09:59:00Z",
  "type": "latency_breach",
  "ref": null,
  "meta": {
    "latency_breach": {
      "mode": "standard",
      "observed_latency": 7.2,
      "ceiling": 6.0,
      "severity": "warning"
    }
  }
}

{
  "tool.call": {
    "id": "lens.archive",
    "payload": {
      "thread": "fracture queue integration",
      "status": "complete"
    }
  }
}
{
  "tool.result": {
    "id": "lens.archive",
    "output": {
      "thread": "fracture queue integration",
      "status": "archived"
    }
  }
}
{
  "tool.call": {
    "id": "lens.boundary",
    "payload": {
      "topic": "latency thresholds"
    }
  }
}
{
  "tool.result": {
    "id": "lens.boundary",
    "output": {
      "topic": "latency thresholds",
      "limits": {
        "lite": "p95=4s",
        "standard": "p95=6s",
        "strict": "p95=12s"
      }
    }
  }
}
{
  "tool.call": {
    "id": "lens.check",
    "payload": {
      "assumption": "All fractures can be resolved immediately."
    }
  }
}
{ "id": "lens.check", "payload": { "assumption": "All dissent is resolved by delay.", "method": "contrast", "proxy": "Record unresolved dissent explicitly." } }
{
  "tool.result": {
    "id": "lens.check",
    "output": {
      "assumption": "All fractures can be resolved immediately.",
      "status": "invalid",
      "reason": "Fractures may persist until review; containment required if unresolved."
    }
  }
}
{
  "tool.call": {
    "id": "lens.contrary",
    "payload": {
      "statement": "Containment protects session integrity."
    }
  }
}
{
  "tool.result": {
    "id": "lens.contrary",
    "output": {
      "contrary": "Containment undermines session integrity by freezing useful flow."
    }
  }
}
{
  "tool.call": {
    "id": "lens.define",
    "payload": {
      "term": "containment",
      "context": "kernel invariants"
    }
  }
}
{ "id": "lens.define", "payload": { "terms": ["center of gravity","tripwire"], "context": "consensus scan" } }
{
  "tool.call": {
    "id": "lens.edge",
    "payload": {
      "claim": "All fractures are harmful."
    }
  }
}
{
  "tool.call": {
    "id": "lens.facts",
    "payload": {
      "topic": "fracture handling"
    }
  }
}
{
  "tool.result": {
    "id": "lens.facts",
    "output": {
      "facts": [
        "Fractures must be reviewed before closure.",
        "Containment only activates when review_queue is non-empty."
      ]
    }
  }
}
{
  "tool.call": {
    "id": "lens.forge",
    "payload": {
      "materials": ["fracture log", "mode profile", "recap"]
    }
  }
}
{
  "tool.result": {
    "id": "lens.forge",
    "output": {
      "synthesis": "Use recap entries and mode profile history to annotate fracture logs."
    }
  }
}
{
  "reviewQueueIds": ["fxr-001", "fxr-004"],
  "openCount": 2,
  "containment": false,
  "lastOpen": "2025-08-29T12:20:00Z"
}

{
  "tool.result": {
    "id": "lens.latency_status",
    "output": {
      "mode": "standard",
      "last_breach": {
        "ts": "2025-08-29T15:15:00Z",
        "observed_latency": 7.1,
        "ceiling": 6.0,
        "severity": "warning"
      }
    }
  }
}
{
  "tool.call": {
    "id": "lens.meta_conflict",
    "payload": {
      "cases": ["case_1", "case_2", "case_3"],
      "focus": "escalation"
    }
  }
}
{
  "tool.result": {
    "id": "lens.meta_conflict",
    "output": {
      "pattern": "Repeated escalation from latent tension to rupture without intermediate repair.",
      "recommendation": "Introduce REFUSE or WAIT earlier in the sequence."
    }
  }
}
{
  "tool.call": {
    "id": "lens.meta",
    "payload": {
      "lenses": ["edge", "define"],
      "scope": "claim",
      "policy_mode": "strict"
    }
  },
  "tool.error": {
    "code": "E_ANTIPATTERN",
    "message": "EDGE before DEFINE on vague terms is a known anti-pattern"
  }
}
{
  "tool.call": {
    "id": "lens.meta",
    "payload": {
      "lenses": ["define", "edge", "open_questions"],
      "scope": "claim",
      "policy_mode": "strict"
    }
  }
}
{
  "tool.result": {
    "id": "lens.mode_profile_status",
    "output": {
      "mode": "strict",
      "source": "manual",
      "last_change": "2025-08-29T16:30:00Z"
    }
  }
}
{
  "tool.call": {
    "id": "lens.open_questions",
    "payload": {
      "topic": "fracture handling",
      "max_items": 3
    }
  }
}
{
  "tool.call": {
    "id": "lens.recap",
    "payload": {
      "include": ["summary", "last_moves", "open_questions"],
      "max_items": 5
    }
  }
}
{
  "tool.call": {
    "id": "lens.refuse",
    "payload": {
      "reason": "Toxic zone; engagement unsafe."
    }
  }
}
{
  "id": "lens.refuse",
  "payload": {
    "reason": "policy_block",
    "note": "Kernel scope excludes off-platform medical advice.",
    "forward_route": { "label": "safer_alt", "suggestion": "Reframe as general safety checklist." }
  }
}
{
  "tool.result": {
    "id": "lens.refuse",
    "output": {
      "status": "refused",
      "reason": "Toxic zone; engagement unsafe."
    }
  }
}
{
  "entry_id": "uuid-rlzn-001",
  "ts": "2025-08-29T17:45:00Z",
  "type": "lens_output",
  "ref": "lens.relation_zone",
  "meta": {
    "relation_zone": {
      "previous": "yellow",
      "new": "red",
      "trigger": "boundary_violation",
      "details": "Detected shift from cooperative hesitation into adversarial rupture"
    }
  }
}
{
  "tool.call": {
    "id": "lens.self_audit",
    "payload": {
      "scope": "session",
      "detail": "full"
    }
  }
}
{
  "tool.call": {
    "id": "lens.spiral",
    "payload": {
      "thread": "containment debates",
      "iterations": 3
    }
  }
}
{
  "tool.result": {
    "id": "lens.spiral",
    "output": {
      "thread": "containment debates",
      "trajectory": "growth",
      "notes": "Discussion moved from reactive framing â†’ structured pros/cons â†’ protocol alignment."
    }
  }
}
{
  "tool.call": {
    "id": "lens.synth",
    "payload": {
      "inputs": [
        "fracture taxonomy",
        "escalation logs",
        "self-audit notes"
      ]
    }
  }
}
{
  "tool.result": {
    "id": "lens.synth",
    "output": {
      "summary": "Fracture taxonomy + escalation logs highlight review choke points; self-audit notes suggest protocol tuning."
    }
  }
}
{
  "tool.call": {
    "id": "lens.trace",
    "payload": {
      "claim": "Containment is always harmful.",
      "depth": 3
    }
  }
}
{ "id": "lens.trace", "payload": { "claim": "We should defer when heat is ethical.", "depth": 3 } }
{
  "tool.result": {
    "id": "lens.trace",
    "output": {
      "chain": [
        "Premise: Containment interrupts session flow.",
        "Inference: Interruptions create user friction.",
        "Claim: Therefore, containment is harmful."
      ],
      "notes": "Fails to account for safety role of containment."
    }
  }
}
{
  "tool.call": {
    "id": "lens.wait",
    "payload": {
      "note": "Holding escalation review until containment clears."
    }
  }
}
{
  "tool.result": {
    "id": "lens.wait",
    "output": {
      "status": "active",
      "containment": true,
      "note": "Holding escalation review until containment clears."
    }
  }
}
{
  "entry_id": "uuid-8001",
  "ts": "2025-08-29T13:10:00Z",
  "type": "mode_profile_change",
  "ref": null,
  "meta": {
    "mode_profile_change": {
      "previous": "standard",
      "new": "strict",
      "source": "escalation"
    }
  }
}

{
  "tool.call": {
    "id": "move.align_scan",
    "payload": {
      "aim": "Clarify the plan viability",
      "last_output": "Proposed steps without validation"
    }
  }
}

{
  "misalignment": "Aim asks for validation; output assumed success.",
  "suggestion": "Ask: What evidence would falsify this plan?"
}

{
  "tool.call": {
    "id": "move.contrast",
    "payload": {
      "items": ["Option A", "Option B"]
    }
  }
}

{
  "differences": [
    "A: faster; B: safer"
  ],
  "key_point": "Trade speed for safety or vice versa."
}

{
  "tool.call": {
    "id": "move.drift_check",
    "payload": {
      "aim": "Decide on MVP scope",
      "thread": [
        "We should refactor the entire system",
        "Let's talk about monetization"
      ]
    }
  }
}

{
  "drift_description": "Thread diverged from deciding MVP scope.",
  "severity": "med"
}

{
  "tool.call": {
    "id": "move.fracture",
    "payload": {
      "beacon_id": "no_deception",
      "context": "Claim contradicted earlier definition without acknowledgment."
    }
  }
}

{
  "fracture_ids": ["F1"],
  "route_hint": "openq"
}

{
  "tool.call": {
    "id": "move.quick_ref",
    "payload": {
      "session_log": [
        { "type": "tool.result", "id": "lens.check" }
      ]
    }
  }
}

{
  "summary": "Checked key assumption; plan still viable."
}

{
  "tool.call": {
    "id": "move.sandbox",
    "payload": {
      "scenario": "What if we reduce scope by 20%?",
      "constraints": { "fail_soft": true, "word_cap": 24 }
    }
  }
}

{
  "outcome": "Simpler MVP keeps core insight; drops edge cases.",
  "confidence": 0.7,
  "mode": "fail_soft"
}

{
  "tool.call": {
    "id": "move.zone_check",
    "payload": {
      "history": [
        "That won't work.",
        "I don't want to revisit that.",
        "Let's move on."
      ]
    }
  }
}

{
  "zone_label": "messy",
  "score": 62
}

{
  "tool.call": {
    "id": "policy.enforce",
    "payload": {
      "target": "export.request",
      "value": "any"
    }
  }
}

{
  "decision": "block",
  "violations": [{
    "code": "V_EXPORT_DISABLED",
    "reason": "kernel export not permitted"
  }]
}

{
  "entry_id": "uuid-8202",
  "ts": "2025-08-29T13:26:00Z",
  "type": "policy_event",
  "ref": null,
  "meta": {
    "policy_event": {
      "tool": "policy.enforce",
      "action": "apply",
      "target": "spiral.diff_log",
      "decision": "revise",
      "violations": 1,
      "details": "Trimmed to 400 chars"
    }
  }
}

{
  "tool.call": {
    "id": "policy.enforce",
    "payload": {
      "target": "spiral.diff_log",
      "value": "<405 chars ...>"
    }
  }
}

{
  "decision": "revise",
  "violations": [{
    "code": "V_FIELD_TOO_LONG",
    "reason": "Exceeded cap for spiral.diff_log"
  }],
  "value_out": "<trimmed to 400>",
  "cap": 400
}

{
  "tool.call": {
    "id": "policy.query",
    "payload": {
      "target": "archive.summary",
      "value": "Short and sweet."
    }
  }
}

{
  "decision": "allow",
  "violations": []
}

{
  "tool.call": {
    "id": "policy.query",
    "payload": {
      "target": "ledger.append"
    }
  }
}

{
  "decision": "block",
  "violations": [{
    "code": "V_LEDGER_CAP",
    "reason": "ledger at capacity"
  }]
}

{
  "entry_id": "uuid-8201",
  "ts": "2025-08-29T13:25:00Z",
  "type": "policy_event",
  "ref": null,
  "meta": {
    "policy_event": {
      "tool": "policy.query",
      "action": "check",
      "target": "archive.summary",
      "decision": "allow",
      "violations": 0,
      "details": "Within cap"
    }
  }
}

{
  "tool.call": {
    "id": "recap.spec",
    "payload": {
      "include": ["summary", "last_moves", "flags"],
      "max_items": 3,
      "max_words_line": 16
    }
  }
}

{
  "recap_packet": {
    "ts": "2025-08-26T19:12:01Z",
    "kernel": { "version": "1.6.0-dev", "accepted": true },
    "meta_locus": { "accepted": true, "fracture_active": false, "containment": false, "review_queue": [] },
    "summary": {
      "aim_line": "Evaluate plan viability with low risk.",
      "state_line": "steady; no containment; 0 pending."
    },
    "last_moves": [
      { "move_id": "lens.openq", "ts": "2025-08-26T19:11:31Z", "artifact_ref": "-" }
    ],
    "flags": { "drift": "none", "zone": "insight", "uncertainty": "med" },
    "note": "P1 recap â€” session-local; export requires explicit header."
  }
}

{
  "tool.validate": {
    "id": "recap.validator",
    "payload_schema": "recap_validator",
    "payload": {
      "include": ["summary", "open_questions"],
      "max_items": 5,
      "max_words_line": 24
    }
  }
}
{
  "include": ["summary", "last_moves", "open_questions"],
  "max_items": 4,
  "max_words_line": 20
}
{
  "include": ["summary", "nonsense_field"],
  "max_items": 12,
  "max_words_line": 60,
  "extra_key": true
}
{
  "tool.call": {
    "id": "sentinel_spotcheck.run",
    "payload": { "probe_id": "probe-42" }
  }
}

{
  "entry_id": "uuid-9002",
  "ts": "2025-08-29T13:45:01Z",
  "type": "spotcheck_event",
  "ref": "probe-42",
  "meta": {
    "spotcheck_event": {
      "outcome": "ambiguous_evidence",
      "severity": "low",
      "escalated": false,
      "details": "Suggest CONTRARY or CHECK lens"
    }
  }
}

{
  "status": "warn",
  "probe_id": "probe-42",
  "outcome": "ambiguous_evidence",
  "severity": "low",
  "escalated": false,
  "details": "Suggest CONTRARY or CHECK lens",
  "ts": "2025-08-29T13:45:00Z"
}

{
  "meta_locus": {
    "accepted": true,
    "containment": false,
    "review_queue": [],
    "latency_mode": "standard",
    "mode_profile": "standard"
  }
}
{
  "last_signal": "schema_near_miss",
  "last_severity": "warning",
  "mode_profile": "standard",
  "last_change": "2025-08-29T17:45:00Z",
  "history_count": 3
}
{
  "ledger_buffer": [
    {
      "entry_id": "uuid-606",
      "ts": "2025-08-29T19:20:00Z",
      "type": "escalation_event",
      "ref": null,
      "meta": {
        "escalation_event": {
          "source": "canary",
          "tier": 2,
          "action": "escalate_profile",
          "mode_profile": "strict",
          "details": "Escalation quota exceeded",
          "quota_exceeded": true
        }
      }
    }
  ],
  "error": {
    "code": "E_ESCALATION_QUOTA",
    "message": "Escalation quota exceeded for escalation_event entries"
  }
}
{
  "last_source": "validator",
  "last_tier": 3,
  "last_action": "fracture_trigger",
  "mode_profile": "strict",
  "last_change": "2025-08-29T19:10:00Z",
  "history_count": 4
}
{
  "ledger_buffer": [
    {
      "entry_id": "uuid-303",
      "ts": "2025-08-29T18:30:00Z",
      "type": "escalation_event",
      "ref": null,
      "meta": {
        "escalation_event": {
          "source": "canary",
          "tier": 2,
          "action": "escalate_profile",
          "mode_profile": "strict",
          "details": "Two consecutive canary chirps detected"
        }
      }
    }
  ]
}
{
  "meta_locus": {
    "accepted": true,
    "containment": false,
    "review_queue": ["fxr-001"],
    "latency_mode": "standard",
    "mode_profile": "strict"
  },
  "ledger_buffer": [
    {
      "entry_id": "uuid-404",
      "ts": "2025-08-29T18:35:00Z",
      "type": "escalation_event",
      "ref": null,
      "meta": {
        "escalation_event": {
          "source": "validator",
          "tier": 3,
          "action": "fracture_trigger",
          "mode_profile": "strict",
          "details": "Validator failure caused review queue append"
        }
      }
    }
  ]
}
{
  "meta_locus": {
    "accepted": true,
    "containment": true,
    "review_queue": ["fxr-001"],
    "latency_mode": "standard",
    "mode_profile": "strict"
  },
  "ledger_buffer": [
    {
      "entry_id": "uuid-505",
      "ts": "2025-08-29T18:40:00Z",
      "type": "escalation_event",
      "ref": null,
      "meta": {
        "escalation_event": {
          "source": "policy",
          "tier": 4,
          "action": "containment",
          "mode_profile": "strict",
          "details": "Catastrophic cap violation"
        }
      }
    }
  ]
}
{
  "ledger_buffer": []
}
{
  "ledger_buffer": [
    {
      "entry_id": "uuid-456",
      "ts": "2025-08-29T15:15:00Z",
      "type": "latency_breach",
      "ref": null,
      "meta": {
        "mode": "standard",
        "observed_latency": 7.1,
        "ceiling": 6.0,
        "severity": "warning"
      }
    }
  ],
  "latency_status": {
    "mode": "standard",
    "last_breach": {
      "ts": "2025-08-29T15:15:00Z",
      "observed_latency": 7.1,
      "ceiling": 6.0,
      "severity": "warning"
    }
  }
}
{
  "meta_locus": {
    "accepted": false,
    "containment": false,
    "review_queue": [],
    "latency_mode": "standard",
    "mode_profile": "standard"
  }
}
{
  "meta_locus": {
    "accepted": true,
    "containment": false,
    "review_queue": ["fxr-001"],
    "latency_mode": "standard",
    "mode_profile": "standard"
  }
}
{
  "mode": "strict",
  "source": "manual",
  "last_change": "2025-08-29T16:30:00Z"
}
{
  "ledger_buffer": [
    {
      "entry_id": "uuid-202",
      "ts": "2025-08-29T17:15:00Z",
      "type": "canary_report",
      "ref": null,
      "meta": {
        "canary_report": {
          "signal": "unusual_latency",
          "severity": "warning",
          "mode_profile": "standard",
          "details": "Latency spike detected at 2.7s (under cap but outside baseline)"
        }
      }
    }
  ]
}
{
  "ledger_buffer": [
    {
      "entry_id": "uuid-123",
      "ts": "2025-08-29T15:04:05Z",
      "type": "latency_breach",
      "ref": null,
      "meta": {
        "mode": "standard",
        "observed_latency": 5.3,
        "ceiling": 4.0,
        "severity": "warning"
      }
    }
  ]
}
{
  "ledger_buffer": [
    {
      "entry_id": "uuid-101",
      "ts": "2025-08-29T16:45:00Z",
      "type": "mode_profile_change",
      "ref": null,
      "meta": {
        "mode_profile_change": {
          "previous": "standard",
          "new": "strict",
          "source": "manual"
        }
      }
    }
  ]
}
{
  "meta_locus": {
    "accepted": true,
    "containment": false,
    "review_queue": [],
    "latency_mode": "lite",
    "mode_profile": "standard"
  }
}
{
  "meta_locus": {
    "accepted": true,
    "containment": false,
    "review_queue": [],
    "latency_mode": "standard",
    "mode_profile": "strict"
  },
  "ledger_buffer": [
    {
      "entry_id": "uuid-789",
      "ts": "2025-08-29T16:30:00Z",
      "type": "mode_profile_change",
      "ref": null,
      "meta": {
        "mode_profile_change": {
          "previous": "standard",
          "new": "strict",
          "source": "manual"
        }
      }
    }
  ]
}
{
  "tool.call": {
    "id": "glyph.invoke",
    "request_id": "req-001",
    "payload": {
      "id": "zuihitsu.draw",
      "payload": {
        "source": "interpretative/data/zuihitsu/zuihitsu_combined.md",
        "count": 1
      }
    }
  }
}
{
  "event_type": "glyph_zuihitsu",
  "ts": "2025-08-30T15:42:11Z",
  "request_id": "req-001",
  "source": "interpretative/data/zuihitsu/zuihitsu_combined.md",
  "fragments": [
    "She leaned in. â€˜Do you believe in the theory of visitors?â€™"
  ],
  "seed": 993821
}
{
  "tool.result": {
    "id": "glyph.zuihitsu",
    "request_id": "req-001",
    "output": {
      "fragments": [
        "What is invisible might as well be dark."
      ],
      "source": "interpretative/data/zuihitsu/zuihitsu_combined.md",
      "seed": 38291
    }
  }
}
